<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Svelte + TS + Vite App</title>
  </head>
  <body class="prose prose-lg max-w-4xl mx-auto">
    <div class="">
      <div>
        <h1><a href="/">//&nbsp;thinkbeforecoding</a></h1>
      </div>
      <div class="row">
        <div class="span1"></div>
        <div class="span8" id="main">
          <h1 class="title">
            <a href="/post/2021/12/17/functional-event-sourcing-decider"
              >Functional Event Sourcing Decider</a
            >
          </h1>
          <p>
            <em
              >this post is part of the
              <a
                href="https://sergeytihon.com/2021/10/18/f-advent-calendar-2021/"
                >F# Advent Calendar 2021</a
              ></em
            >
          </p>
          <p>
            After years of talks and workshops about Functional Event Sourcing,
            I noticed that I published only 4 posts on the topic.
          </p>
          <p>
            The first of them is a
            <a href="/post/2013/07/28/Event-Sourcing-vs-Command-Sourcing"
              >rant in 2013</a
            >
            about
            <a href="https://www.martinfowler.com/eaaDev/EventSourcing.html"
              >Martin Fowler's article from 2005</a
            >
            describing something that could be called Command Sourcing and is
            misleading people into thinking they are doing Event Sourcing.
          </p>
          <p>
            The second is a
            <a href="/post/2014/01/04/Event-Sourcing.-Draw-it"
              >simple drawing</a
            >
            describing the flow of Functional Event Sourcing. Really useful,
            many people told me something clicked once they saw this picture.
            But still a bit short. I made a few wording changes since then.
          </p>
          <p>
            I then made two posts about
            <a href="/post/2014/04/11/Monoidal-Event-Sourcing">Monoidal</a>
            <a href="/post/2014/04/27/Monoidal-Event-Sourcing-Examples"
              >Event Sourcing</a
            >
            trying theoretical ideas to change this
            <a
              href="http://thinkbeforecoding.github.io/FsUno.Prod/Dynamical%20Systems.html"
              >external monoid</a
            >
            to a plain monoid.
          </p>
          <p>
            It was accompanied by many samples on github like the many
            <a href="https://github.com/thinkbeforecoding/UnoCore">FsUno</a>
            implementations, the
            <a
              href="https://github.com/thinkbeforecoding/hackyourjob-crazyeights"
              >crazyeight</a
            >
            workshop as well as the source code of
            <a href="https://github.com/thinkbeforecoding/crazy"
              >Crazy Farmers</a
            >' port for
            <a href="https://boardgamearena.com/gamepanel?game=crazyfarmers"
              >Board Game Arena</a
            >
            that is using both Server Side and Client Side event sourcing, the
            client side being transpiled to JS using Fable, and the server side
            to PHP using peeble.
          </p>
          <p>
            I'm currently working on a book about it, but writing books takes
            time. And digging the topic led me to discover new things that make
            it even longer to write.
          </p>
          <p>
            So here it is, a beginner introduction to Functional Event Sourcing
            and its main pattern, the Decider.
          </p>
          <h2>
            <a
              name="Anatomy-of-a-Service"
              class="anchor"
              href="#Anatomy-of-a-Service"
              >Anatomy of a Service</a
            >
          </h2>
          <p>Let's look at a System. Any System.</p>
          <p>
            Without interactions with the outside, such a system would be pretty
            useless. We can represent these interactions in a generic way as
            inputs and outputs
          </p>
          <table class="pre break-inside-avoid">
            <tbody>
              <tr>
                <td class="snippet">
                  <pre
                    class="fssnip"
                  ><code lang="txt">              ┌────────────────────┐
              │                    │ 
 Inputs       │                    │     Outputs
    ─────────►│       System       │───────────►
              │                    │
              │                    │
              └────────────────────┘
</code></pre>
                </td>
              </tr>
            </tbody>
          </table>
          <p>
            A system that accepts inputs but produces no outputs would be a kind
            of black hole.
          </p>
          <table class="pre break-inside-avoid">
            <tbody>
              <tr>
                <td class="snippet">
                  <pre
                    class="fssnip"
                  ><code lang="txt">              ┌────────────────────┐
              │       System       │ 
 Inputs       │                    │ 
    ─────────►│     (the void)     │
              │                    │
              │                    │
              └────────────────────┘
</code></pre>
                </td>
              </tr>
            </tbody>
          </table>
          <p>this is not totally useless (cf /dev/null), but quite limited.</p>
          <p>
            On the other hand, a system that produces outputs without inputs
            seems also very simplistic. Without introducing time, it would
            necessarily be a constant:
          </p>
          <table class="pre break-inside-avoid">
            <tbody>
              <tr>
                <td class="snippet">
                  <pre
                    class="fssnip"
                  ><code lang="txt">              ┌────────────────────┐
              │                    │  Constant
              │                    │     Outputs
              │       System       │───────────►
              │                    │
              │                    │
              └────────────────────┘
</code></pre>
                </td>
              </tr>
            </tbody>
          </table>
          <p>So let's introduce time. Lets add a clock to our system.</p>
          <table class="pre break-inside-avoid">
            <tbody>
              <tr>
                <td class="snippet">
                  <pre
                    class="fssnip"
                  ><code lang="txt">              ┌────────────────────┐
              │  Clock             │  
              │                    │     Outputs
              │       System       │───────────►
              │                    │
              │                    │
              └────────────────────┘
</code></pre>
                </td>
              </tr>
            </tbody>
          </table>
          <p>
            The problem of clock is that is is changing over time (obviously),
            so let's refactor to treat clock as an input (it also becomes a
            trigger):
          </p>
          <table class="pre break-inside-avoid">
            <tbody>
              <tr>
                <td class="snippet">
                  <pre
                    class="fssnip"
                  ><code lang="txt">              ┌────────────────────┐
              │  Clock    System   │ 
              │   │                │
              │   ▼                │    Outputs
              │  ┌──────────────┐  │
              │  │  Subsystem   │───────────────►
              │  └──────────────┘  │
              └────────────────────┘
</code></pre>
                </td>
              </tr>
            </tbody>
          </table>
          <p>
            Here, our system is a pure function of time. This can be useful, but
            most of the systems we deal with are a bit more complicated.
          </p>
          <p>
            As we wanted interactions, we can reintroduce inputs as triggers.
            For instance a user action.
          </p>
          <table class="pre break-inside-avoid">
            <tbody>
              <tr>
                <td class="snippet">
                  <pre
                    class="fssnip"
                  ><code lang="txt">              ┌───────────────────┐
              │  Clock    System  │ 
              │   │               │
 Actions      │   ▼               │    Outputs
              │  ┌─────────────┐  │
    ────────────►│  Subsystem  │───────────────►
              │  └─────────────┘  │
              └───────────────────┘
</code></pre>
                </td>
              </tr>
            </tbody>
          </table>
          <p>
            To go back on the question of time, some time is passed in the
            system during code execution. But at today’s execution speed,
            especially outside of inputs/outputs, code execution can be
            considered as instant. To be executed the code needs some trigger to
            be called and run.
          </p>
          <p>
            A user action can be such a trigger, in this case, current time can
            be seen as one parameter of the action.
          </p>
          <p>
            The trigger can also be the clock (a timer, an alarm..) but still
            the code is called for some reason (it's time for the Market to
            close, a check must be made every 5 minutes...). In this case, this
            is a scheduled automatic action, but it's still an action with
            current time as additional data.
          </p>
          <p>
            Most of the time, the output not only depends on the input action,
            but also on what happened before.
          </p>
          <p>
            The system needs a way to keep a trace of the effects of previous
            action to react accordingly.
          </p>
          <p>
            Without such memory, the system is always reacting the same way to
            the same input action, regardless of anything that happened in the
            past. Some systems behave like this, but are a constrained case of
            more general systems that keep a trace of past actions.
          </p>
          <p>
            This memory is called state and is accessed and modified by the
            system code. It can be stored in memory (RAM) or saved to a
            database. Reading it can be considered a sort of input, changing it
            a sort of output:
          </p>
          <table class="pre break-inside-avoid">
            <tbody>
              <tr>
                <td class="snippet">
                  <pre
                    class="fssnip"
                  ><code lang="txt">              ┌───────────────────┐
              │  Clock    System  │ 
              │   │               │
 Actions      │   ▼               │    Outputs
              │  ┌─────────────┐  │
    ────────────►│  Subsystem  │───────────────►
              │  └─────────────┘  │
              │     ▲        │    │
              │     │        ▼    │
              │  ┌─────────────┐  │
              │  │    State    │  │
              │  └─────────────┘  │
              └───────────────────┘
</code></pre>
                </td>
              </tr>
            </tbody>
          </table>
          <p>
            This is a useful step. The subsystem can be cleared of a lot of
            technical concerns. The input interfaces can be abstracted (HTTP
            API, message queue, UI events, command line arguments, timers or
            alarms...) and parameters can be passed to the subsystem directly.
            The output interaction can also be abstracted and hidden behind
            interfaces (Outbound HTTP calls, messages or notification
            sending...). State loading and saving can also be hidden behind an
            interface to protect the subsystem from implementation details.
          </p>
          <p>
            Once carefully cleared from technical concerns, the code in the
            subsystem is merely composed of the system logic. What we commonly
            call the business logic, or Domain. We call the rest of the code the
            Application layer.
          </p>
          <p>
            We described here the hexagonal architecture where the application
            core, the Domain, is loosely coupled to its environment through port
            interfaces, implemented as adapters to the technical infrastructure.
          </p>
          <h2>
            <a name="Functional-Core" class="anchor" href="#Functional-Core"
              >Functional Core</a
            >
          </h2>
          <p>
            We can go a bit further by applying
            <a href="/post/2018/01/25/functional-core">Functional Core</a> to
            our model. The idea is to write the Subsystem as a pure function.
          </p>
          <p>
            The input Actions and Clock will be passed as input values (the
            current time, if needed in the case of the clock). Actually we can
            consider current time as being a parameter of the action, and will
            not mention it again.
          </p>
          <p>
            For state, we can also load its current value, and pass it to the
            function. And the function will return a new state that can be
            stored.
          </p>
          <p>
            Outputs and side effects can also be returned as values by the
            functions, and the side effects will be performed by the application
            layer:
          </p>
          <pre
            class="fssnip highlighted"
          ><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, '5', 8)" onmouseover="showTip(event, '5', 8)" class="fn">subsystem</span> <span class="pn">(</span><span onmouseout="hideTip(event, '6', 9)" onmouseover="showTip(event, '6', 9)" class="fn">action</span><span class="pn">:</span> <span onmouseout="hideTip(event, '2', 10)" onmouseover="showTip(event, '2', 10)" class="rt">Action</span><span class="pn">)</span> <span class="pn">(</span><span onmouseout="hideTip(event, '7', 11)" onmouseover="showTip(event, '7', 11)" class="fn">state</span><span class="pn">:</span> <span onmouseout="hideTip(event, '3', 12)" onmouseover="showTip(event, '3', 12)" class="rt">State</span><span class="pn">)</span> <span class="pn">:</span> <span onmouseout="hideTip(event, '3', 13)" onmouseover="showTip(event, '3', 13)" class="rt">State</span> <span class="pn">*</span> <span onmouseout="hideTip(event, '4', 14)" onmouseover="showTip(event, '4', 14)" class="rt">Output</span> <span onmouseout="hideTip(event, '8', 15)" onmouseover="showTip(event, '8', 15)" class="rt">list</span> <span class="o">=</span>
    <span onmouseout="hideTip(event, '7', 16)" onmouseover="showTip(event, '7', 16)" class="fn">state</span><span class="pn">,</span> <span class="pn">[</span><span class="pn">]</span>
</code></pre>
          <p>
            This is here, obviously a system that does nothing. By returning a
            new state, it will be persisted for the next call, and by returning
            output, it will be able to product other side effects.
          </p>
          <h2>
            <a
              name="Actions-and-Commands"
              class="anchor"
              href="#Actions-and-Commands"
              >Actions and Commands</a
            >
          </h2>
          <p>
            The Functional Core Domain is called on external triggers we called
            Actions. We can group them initially in two groups, Commands and
            Events.
          </p>
          <p>
            A command is an action on the system with an intention to change it.
            A user places an order, cancels a subscription, books a hotel room.
            It can succeed of fail, but should have an effect on the system.
          </p>
          <p>
            On the other side, something can happen outside of the system that
            should have an effect on it. The weather changed, a customer checked
            out, a cargo left a harbor, a scheduled alarm expired. Those things
            happened and there's nothing we can do about it. This can trigger a
            change in the system. We call them External Events.
          </p>
          <p>
            Our Functional Core domain could directly take External Events as an
            input, be we can find in the Domain internal Commands associated.
            The WeatherChanged event leads to a PrepareForRain command. It's
            4PM, the market bell rang, this is a CloseMarket command.
          </p>
          <p>
            In the same way, in user interface code it is advised to not take
            action directly in event handler's code. In the onButtonClicked
            function, it is better to call another DoAction() function that does
            the actual action. The code is clearer and the action can then be
            called on different triggers, and just tested without having to
            raise the event itself.
          </p>
          <p>
            There is also a distinction between External Command and Internal
            Command. Current time can be important to process a command, and
            will be part of input data. However, current time will not be
            provided by the Command sender as it would be highly unsafe, caller
            could ante/postdate the Command. The External Command is enriched
            with current time in the Application layer. Same thing for external
            data as exchange rates, weather conditions or resources protected by
            access rights. Caller identity should also be used with care, it can
            be either validated using a password, access-key, signature or login
            check.
          </p>
          <p>
            We will now consider any Domain input action as an internal Command
            containing all enrichment data and call it a Command from brevity. A
            Command can be implemented as a data structure with a name
            indicating its intent and containing the associated data. Its name
            is always a verbal phrase in the imperative.
          </p>
          <h2>
            <a name="Decision" class="anchor" href="#Decision">Decision</a>
          </h2>
          <p>
            The next step is to look inside the Functional Core Domain and split
            it even further.
          </p>
          <p>
            It's a pure function that takes a Command and current State and
            returns a State an some Outputs.
          </p>
          <p>
            The usual way to proceed in fulfilling a Command given current State
            is to modify State according to business rules. The code checks what
            the situation is and follows the rules defined by the domain to
            modify the State in a consistent way.
          </p>
          <p>
            Doing this, we're going a bit too fast. We take some shortcuts. We
            take decisions and apply the effects of these decisions at the same
            time. There are two quite different steps, and making the conflation
            obscures the actual decision process.
          </p>
          <p>
            Letting the decision process implicit proves to be problematic.
            Looking at data, the business is wondering why we ended up in
            current state. Is it a bug or legit actions that produced this
            unexpected result? Tracing back observable side effects and saved
            intermediate state is time consuming and cannot always give
            definitive answers.
          </p>
          <h3>
            <a name="Against-log" class="anchor" href="#Against-log"
              >Against log</a
            >
          </h3>
          <p>
            This often leads to bloating the code with logs. Logs are initially
            useful, but they don't age well. They are added on second thought,
            and seldom tested. Like commands, after a few refactorings, they
            most often end up outdated, reporting incorrect and/or partial
            traces. Having up to date correct logs requires to be careful. On
            the first carelessness occurrence the data in the log will become
            unreliable. This becomes quickly a time hog during diagnosis,
            especially when unexpected cases happen, everything needs to be
            double checked, in the traces and in the code that may have changed
            in-between.
          </p>
          <p>
            As an afterthought, their operation is also not designed with care.
            Log retention is costly, and choosing the right log level is
            difficult. Too verbose, logs storage price can become prohibitive,
            forcing a short retention period. Not verbose enough, important
            information can be missing. Cleaning logs is also difficult because
            not all logs are of equal importance, nor is everything equally
            relevant after some time. Sadly log systems rarely give much
            flexibility in the cleaning/archiving process. All this becomes
            useless anyway if the log cannot be trusted.
          </p>
          <h3><a name="Events" class="anchor" href="#Events">Events</a></h3>
          <p>
            To avoid this, we decide to untangle decision taking and state
            changing. We'll be explicit about what happens by materializing
            decisions outcome before changing state, and changing state only
            using data from this decision.
          </p>
          <p>
            We will express these Commands processing outcomes as Events
            expressing as past tense verbs what just happened to the system,
            leading to a new state.
          </p>
          <p>
            A Switch Light On Command will produce Light Switched On Event if
            any. A Transfer Money Command will produce a Money Transferred
            Event, or a Money Transfer Rejected Event due to insufficient funds.
          </p>
          <p>Decision then just take this simple form:</p>
          <table class="pre break-inside-avoid">
            <tbody>
              <tr>
                <td class="snippet">
                  <pre
                    class="fssnip"
                  ><code lang="txt"> Command      ┌───────────────────┐    
    ─────────►│                   │    Events
 State        │      Decide       │─────────►
    ─────────►│                   │
              └───────────────────┘
</code></pre>
                </td>
              </tr>
            </tbody>
          </table>
          <p>
            If we use simple data structures for Commands, State and Events, the
            decision can be implemented as a function with the following
            signature:
          </p>
          <pre
            class="fssnip highlighted"
          ><code lang="fsharp"><span class="k">type</span> <span onmouseout="hideTip(event, '11', 21)" onmouseover="showTip(event, '11', 21)" class="fn">Decide</span> <span class="o">=</span> <span onmouseout="hideTip(event, '9', 22)" onmouseover="showTip(event, '9', 22)" class="rt">Command</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, '3', 23)" onmouseover="showTip(event, '3', 23)" class="rt">State</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, '10', 24)" onmouseover="showTip(event, '10', 24)" class="rt">Event</span> <span onmouseout="hideTip(event, '8', 25)" onmouseover="showTip(event, '8', 25)" class="rt">list</span>
</code></pre>
          <p>
            Since we decided to not modify state at this stage, the State can be
            immutable (read only) as should Command and Event be.
          </p>
          <p>
            This function has no reason to produce any side effects, like
            reading or writing external state, or calling external services.
            We've seen how to deal with external data like current time or
            exchange rates already. So it can be implemented as a
            <strong>pure function</strong>:
          </p>
          <ul>
            <li>Its return value should depend only on the input parameters</li>
            <li>It should not produce any noticeable external side effect.</li>
          </ul>
          <p>
            The first point is really interesting for testing and reasoning
            about the code. Given current State and Command, the resulting Event
            list is always the same. This is true whatever the day and time and
            whatever the current state anywhere else. It eases the tests that
            will never be dependent on external concerns. It also eases
            debugging since if we logged the Command data and are able to know
            State at that point in time - which we’ll do - there is only a
            single possible outcome. This forces us to not depend on any
            external data that is not already in State or Command parameters, as
            current time or external data retrieval.
          </p>
          <p>
            The second point stems from our choice to make decision explicit. If
            the function produces any side effect, it will break our principle
            to first express the decision taken before making any change. We’ll
            also see why even logging is useless inside this function.
          </p>
          <p>This constraints give a lot of interesting properties.</p>
          <p>In summary decision function is a way to write:</p>
          <table class="pre break-inside-avoid">
            <tbody>
              <tr>
                <td class="snippet">
                  <pre
                    class="fssnip"
                  ><code lang="txt">When asked to process this Command while in given State, here is what happens, expressed as Events. 
</code></pre>
                </td>
              </tr>
            </tbody>
          </table>
          <h2>
            <a name="Evolution" class="anchor" href="#Evolution">Evolution</a>
          </h2>
          <p>
            We’ve decided to split taking decision and applying resulting
            changes. The goal was to make the actual decision taken more
            explicit in the code base. So in previous part, we devised a decide
            function that returns Events but does not actually change State.
            Now, let’s see how to apprehend change in a simple and highly
            testable way. This will actually be quite straight forward.
          </p>
          <p>
            To compute the new State, we need of course the current State and
            the Event that just happened.
          </p>
          <p>
            We could modify current State to mutate it so it becomes the new
            State, but this is not how we’ll proceed. Mutation will not
            automatically lead you to bad code and bugs, but we can consider it
            a premature optimization at this point. If you’re not familiar with
            Functional Programming, immutability can seem very costly and
            inefficient, and this can be correct in some contexts. But most
            modern languages, functional or not, are fast enough in immutable
            scenarios compared to querying a database or making a network call.
            The result is that the overhead of immutability at the level of
            domain code can often be ignored. We’ll see how immutable data
            structure for state helps reasoning about the code, and how it has
            interesting composition properties. So let’s just go on with
            immutable State, and you’ll decide of your implementation based on
            your own stack constraints later.
          </p>
          <p>
            The decision function was returning an Event list containing zero,
            one or more events, and we will focus first on how to deal with a
            single Event. It will be easy from there do handle multiple events.
          </p>
          <p>
            With immutable read only State data structure and read only Event,
            it becomes obvious that computing new State will be implemented also
            as a pure function. There is now way to change provided current
            State and Event, they are read only. The Event and the State should
            contain all the data we need, so there is no point fetching data
            from somewhere else. No external service calls. Then, mutating data
            outside would be equivalent to use global state which would defeat
            the purpose of all this. We have all data at hand, and just have to
            compute the new state to return it. We’ll see further that there is
            also no reason for things like logging or tracing in this code.
          </p>
          <p>Let’s call this function evolve, its signature is:</p>
          <pre
            class="fssnip highlighted"
          ><code lang="fsharp"><span class="k">type</span> <span onmouseout="hideTip(event, '12', 26)" onmouseover="showTip(event, '12', 26)" class="fn">Evolve</span> <span class="o">=</span> <span onmouseout="hideTip(event, '3', 27)" onmouseover="showTip(event, '3', 27)" class="rt">State</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, '10', 28)" onmouseover="showTip(event, '10', 28)" class="rt">Event</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, '3', 29)" onmouseover="showTip(event, '3', 29)" class="rt">State</span>
</code></pre>
          <p>
            It takes a State and an Event and returns a State. Its meaning is:
            Given current State, when Event occurs, here is the new State.
          </p>
          <p>
            The code of the evolve function should be extremely simple. Decision
            has already been taken. It should probably not be more that setting
            a field, adding a element to a list, or incrementing a value, or
            setting/reseting a flag.
          </p>
          <p>
            The evolve function is core to Event Sourcing but it will rarely be
            more complicated than a few lines of codes.
          </p>
          <h2>
            <a name="Initial-State" class="anchor" href="#Initial-State"
              >Initial State</a
            >
          </h2>
          <p>
            For the first Command, we find ourselves in a specific situation. We
            have a Command and a decide function. But the decide function needs
            an input state, and we have no State for now that we can pass as a
            parameter. Same thing with the evolve function on the first Event.
          </p>
          <p>
            If we consider the state returned by the evolve function and this
            first Event, we can obviously say that it's the State after the
            first Event occurs. So the input state is the State before the first
            Event occurs, when nothing occurred yet. We will call it Initial
            State.
          </p>
          <p>
            Initial State is important as it has to be explicitly defined. Some
            times it can be chosen between possible further States. For a light,
            for instance, it could be On or Off. For an account, it could be
            defined with a 0 balance. It will just use specific values for the
            properties, and it is totally possible that it will be back in the
            same state later. The light will be Off again, and the account could
            return to a 0 balance in the future.
          </p>
          <p>
            However, the first Event is sometime irreversible. For a card game,
            before the first event happens, the game is not yet started. After
            the first event, it is started, it will eventually end, bit will not
            be in the "not started yet state" anymore. This situation often
            arises when some initial properties have to be defined, when an
            initial actions sets the system up. In a card game, the dealer will
            put the first card on the table. This is action that can only happen
            at the beginning, it's the game setup. It marks the actual start of
            the game, before that, no other action can take place.
          </p>
          <p>
            In this case, the initial State has no other property than being the
            action Initial State. It doesn't need to contain more information.
            It is easy to represent such state in languages with sum types or
            discriminated unions:
          </p>
          <pre
            class="fssnip highlighted"
          ><code lang="fsharp">  <span class="k">type</span> <span onmouseout="hideTip(event, '14', 32)" onmouseover="showTip(event, '14', 32)" class="rt">State</span> <span class="o">=</span>
      <span class="pn">|</span> <span onmouseout="hideTip(event, '15', 33)" onmouseover="showTip(event, '15', 33)" class="uc">InitialState</span>
      <span class="pn">|</span> <span onmouseout="hideTip(event, '16', 34)" onmouseover="showTip(event, '16', 34)" class="uc">Started</span> <span class="k">of</span> <span class="prop">topCard</span><span class="pn">:</span> <span onmouseout="hideTip(event, '13', 35)" onmouseover="showTip(event, '13', 35)" class="rt">Card</span>

  <span class="k">let</span> <span onmouseout="hideTip(event, '17', 36)" onmouseover="showTip(event, '17', 36)" class="id">initialState</span> <span class="o">=</span> <span onmouseout="hideTip(event, '15', 37)" onmouseover="showTip(event, '15', 37)" class="uc">InitialState</span>
</code></pre>
          <p>
            This indicates that the state is either InitialState without any
            more information, or the game is Stated with the specified top card.
          </p>
          <p>
            In languages without sum types, we'll usually use a boolean or enum
            value to mark the difference:
          </p>
          <pre
            class="fssnip highlighted"
          ><code lang="fsharp">  <span class="k">type</span> <span onmouseout="hideTip(event, '18', 38)" onmouseover="showTip(event, '18', 38)" class="rt">State</span> <span class="o">=</span>
    <span class="pn">{</span> <span onmouseout="hideTip(event, '19', 39)" onmouseover="showTip(event, '19', 39)" class="prop">Started</span><span class="pn">:</span> <span onmouseout="hideTip(event, '20', 40)" onmouseover="showTip(event, '20', 40)" class="vt">bool</span> 
      <span onmouseout="hideTip(event, '21', 41)" onmouseover="showTip(event, '21', 41)" class="prop">TopCard</span><span class="pn">:</span> <span onmouseout="hideTip(event, '13', 42)" onmouseover="showTip(event, '13', 42)" class="rt">Card</span><span class="pn">}</span>
  <span class="k">let</span> <span onmouseout="hideTip(event, '17', 43)" onmouseover="showTip(event, '17', 43)" class="id">initialState</span> <span class="o">=</span>
    <span class="pn">{</span> <span class="prop">Started</span> <span class="o">=</span> <span class="k">false</span>
      <span class="prop">TopCard</span> <span class="o">=</span> <span onmouseout="hideTip(event, '22', 44)" onmouseover="showTip(event, '22', 44)" class="m">Unchecked</span><span class="pn">.</span><span onmouseout="hideTip(event, '23', 45)" onmouseover="showTip(event, '23', 45)" class="id">defaultof</span><span class="pn">&lt;</span><span onmouseout="hideTip(event, '13', 46)" onmouseover="showTip(event, '13', 46)" class="rt">Card</span><span class="pn">&gt;</span> <span class="pn">}</span>
</code></pre>
          <p>
            You can notice here that two problems arise. First, we have to be
            careful not to use the TopCard property when Started is false.
            Should we use an exception or a similar error mechanism to prevent
            this from happening? Probably, but it would be far better to not be
            able to write such code in a first place. Second, what is a good
            value for TopCard in the initial state when Started is false ? Here
            I chose a club three which can seems a bit arbitrary, but any value
            would be. There is no good Card type value that naturally represents
            a default value. In some language, an option would be to use null,
            but this is also dangerous if null is never a valid value once
            started. Null Reference Exceptions are frequent errors that are
            better avoided from the start. If ready to use null the next option
            would be to use it and get rid of Started altogether.
          </p>
          <p>
            On the pro side, this makes state more compact, and avoids requiring
            a check on a property to know if the other is valid potentially
            leading to consistency problems. On the cons, the initial state is
            less explicit. The code doesn’t express clearly when it is valid to
            have a TopCard or not.
          </p>
          <h2>
            <a
              name="Stitching-it-together"
              class="anchor"
              href="#Stitching-it-together"
              >Stitching it together</a
            >
          </h2>
          <p>
            Now we have all the parts needed for Event Sourcing. Let's use them
            together. We have three types and three elements described in the
            previous chapters that have the following signatures:
          </p>
          <pre
            class="fssnip highlighted"
          ><code lang="fsharp"><span class="k">type</span> <span onmouseout="hideTip(event, '24', 47)" onmouseover="showTip(event, '24', 47)" class="rt">Command</span>
<span class="k">type</span> <span onmouseout="hideTip(event, '25', 48)" onmouseover="showTip(event, '25', 48)" class="rt">Event</span>
<span class="k">type</span> <span onmouseout="hideTip(event, '26', 49)" onmouseover="showTip(event, '26', 49)" class="rt">State</span>
<span class="id">initialState</span><span class="pn">:</span> <span onmouseout="hideTip(event, '26', 50)" onmouseover="showTip(event, '26', 50)" class="id">State</span>
<span class="id">decide</span><span class="pn">:</span> <span onmouseout="hideTip(event, '24', 51)" onmouseover="showTip(event, '24', 51)" class="id">Command</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, '26', 52)" onmouseover="showTip(event, '26', 52)" class="id">State</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, '25', 53)" onmouseover="showTip(event, '25', 53)" class="id">Event</span> <span onmouseout="hideTip(event, '8', 54)" onmouseover="showTip(event, '8', 54)" class="id">list</span>
<span class="id">evolve</span><span class="pn">:</span> <span onmouseout="hideTip(event, '26', 55)" onmouseover="showTip(event, '26', 55)" class="id">State</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, '25', 56)" onmouseover="showTip(event, '25', 56)" class="id">Event</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, '26', 57)" onmouseover="showTip(event, '26', 57)" class="id">State</span>
</code></pre>
          <p>
            The Command will come from the outside, but the State and Event list
            will be fed from the decide function output to the evolve function
            input while the output State from the evolve function will be passed
            to the next call to the decide function. The output State will also
            be used as an input parameter for the next call to the evolve
            function.
          </p>
          <table class="pre break-inside-avoid">
            <tbody>
              <tr>
                <td class="snippet">
                  <pre
                    class="fssnip"
                  ><code lang="txt">         Command  ┌──────────────┐
        ─────────►│              │ Events
         State    │    decide    ├───────┐
        ┌────────►│              │       │
        │         └──────────────┘       │
        │         ┌──────────────┐ Event │
        │  State  │              │◄──────┘
        ├───◄─────┤    evolve    │ State
        │         │              │◄──────┐
        │         └──────────────┘       │
        └────────────────────────────────┘
</code></pre>
                </td>
              </tr>
            </tbody>
          </table>
          <p>
            When the system initially starts, it is in the Initial State. For
            now, nothing happened yet.
          </p>
          <p>
            When the first command arrives, we have a Command and a State that
            we can pass to the decide function. It will return the outcomes of
            the Command as a list of Event, the things that happened in reaction
            to the input Command.
          </p>
          <p>
            If the output Event list is empty, nothing happened, no need to
            compute a new state, we are ready for the next Command. This should
            not happen frequently for at least two reasons. A system that does
            mostly nothing is not very interesting and may probably be
            implemented without Event Sourcing... But doing nothing can also
            make some situation harder to diagnose. When a Command was intended
            to do something but resulted in no change, it can be interesting to
            know the reasons. Emitting no Events will make the distinction
            between an infrastructure problem and a motivated decision to do
            nothing harder to find. Did the system crash, or did it just decide
            to do nothing?
          </p>
          <p>
            It is still possible to know by taking the Command that has been
            persisted for diagnostic and State that can be reconstructed from
            past Events, pass them to the decide function and see the result,
            but it will request careful code analysis or creating a new test
            with this specific data. This takes on developers time and is better
            avoided.
          </p>
          <p>
            If the decision to do nothing results from a business rule, it is
            advised to make it explicit, and return an Event that will not
            affect State. It will clearly appear in the produced Events and
            diagnostics will be easy. This can be done by support teams that
            have no access to the code.
          </p>
          <p>
            If nothing happens because we are already in expected state, we are
            in a case of idempotent Command. In this case, it is actually better
            to return no Events. It avoids bloating the Event Store with useless
            duplicate Events.
          </p>
          <p>
            When the Event list contains an Event, we can call the evolve
            function with current State and this Event. It will return the new
            State, to be used for the next Command instead of the Initial State.
          </p>
          <p>
            Sometimes the Event list will contain several Events. In this case
            we will call the evolve function for each event passing previous
            computed State along.
          </p>
          <p>This could give something like:</p>
          <pre
            class="fssnip highlighted"
          ><code lang="fsharp"><span class="k">let</span> <span class="id">newState1</span> <span class="o">=</span> <span class="id">evolve</span> <span class="id">currentState</span> <span class="id">event1</span>
<span class="k">let</span> <span class="id">newState2</span> <span class="o">=</span> <span class="id">evolve</span> <span class="id">newState1</span> <span class="id">event2</span>
<span class="k">let</span> <span class="id">newState3</span> <span class="o">=</span> <span class="id">evolve</span> <span class="id">newState2</span> <span class="id">event3</span>
</code></pre>
          <p>
            We can do better, but we now have the next current State and we are
            ready to process the next Command.
          </p>
          <h2><a name="Fold" class="anchor" href="#Fold">Fold</a></h2>
          <p>
            When we have several events, we have to call the evolve function for
            each.
          </p>
          <p>A simple way to do it is to use a loop:</p>
          <pre
            class="fssnip highlighted"
          ><code lang="fsharp"><span class="k">let</span> <span onmouseout="hideTip(event, '30', 65)" onmouseover="showTip(event, '30', 65)" class="fn">computeNextState</span> <span onmouseout="hideTip(event, '31', 66)" onmouseover="showTip(event, '31', 66)" class="fn">currentState</span> <span onmouseout="hideTip(event, '32', 67)" onmouseover="showTip(event, '32', 67)" class="fn">events</span> <span class="o">=</span>
    <span class="k">let</span> <span class="k">mutable</span> <span onmouseout="hideTip(event, '33', 68)" onmouseover="showTip(event, '33', 68)" class="mv">state</span> <span class="o">=</span> <span onmouseout="hideTip(event, '31', 69)" onmouseover="showTip(event, '31', 69)" class="fn">currentState</span>
    <span class="k">for</span> <span onmouseout="hideTip(event, '28', 70)" onmouseover="showTip(event, '28', 70)" class="fn">event</span> <span class="k">in</span> <span onmouseout="hideTip(event, '32', 71)" onmouseover="showTip(event, '32', 71)" class="fn">events</span> <span class="k">do</span>
        <span onmouseout="hideTip(event, '33', 72)" onmouseover="showTip(event, '33', 72)" class="mv">state</span> <span class="k">&lt;-</span> <span onmouseout="hideTip(event, '27', 73)" onmouseover="showTip(event, '27', 73)" class="fn">evolve</span> <span onmouseout="hideTip(event, '33', 74)" onmouseover="showTip(event, '33', 74)" class="mv">state</span> <span onmouseout="hideTip(event, '28', 75)" onmouseover="showTip(event, '28', 75)" class="fn">event</span>
    <span onmouseout="hideTip(event, '33', 76)" onmouseover="showTip(event, '33', 76)" class="mv">state</span>
</code></pre>
          <p>
            As you can see, F# makes mutability explicit through the mutable
            keyword. Without it, state cannot be assigned to a new value... It
            also uses this backward looking left arrow <code>&lt;-</code> which
            seems to suggest that we're going in the wrong direction. F# IDEs
            also tend to display mutable variables in oranges to signal them as
            a kind of warning...
          </p>
          <p>
            Another way to proceed without mutation is to use a recursive
            function that we will call fold:
          </p>
          <pre
            class="fssnip highlighted"
          ><code lang="fsharp"><span class="k">let</span> <span class="k">rec</span> <span onmouseout="hideTip(event, '34', 77)" onmouseover="showTip(event, '34', 77)" class="fn">fold</span> <span onmouseout="hideTip(event, '7', 78)" onmouseover="showTip(event, '7', 78)" class="fn">state</span> <span onmouseout="hideTip(event, '35', 79)" onmouseover="showTip(event, '35', 79)" class="fn">events</span> <span class="o">=</span>
    <span class="k">match</span> <span onmouseout="hideTip(event, '35', 80)" onmouseover="showTip(event, '35', 80)" class="fn">events</span> <span class="k">with</span>
    <span class="pn">|</span> <span class="pn">[</span><span class="pn">]</span> <span class="k">-&gt;</span>     <span class="c">// there is no events..</span>
        <span onmouseout="hideTip(event, '7', 81)" onmouseover="showTip(event, '7', 81)" class="fn">state</span>   <span class="c">// nothing changed</span>
    <span class="pn">|</span> <span onmouseout="hideTip(event, '28', 82)" onmouseover="showTip(event, '28', 82)" class="fn">event</span> <span class="uc">::</span> <span onmouseout="hideTip(event, '36', 83)" onmouseover="showTip(event, '36', 83)" class="fn">rest</span> <span class="k">-&gt;</span>
        <span class="c">// compute state after first event</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, '37', 84)" onmouseover="showTip(event, '37', 84)" class="fn">newState</span> <span class="o">=</span> <span onmouseout="hideTip(event, '27', 85)" onmouseover="showTip(event, '27', 85)" class="fn">evolve</span> <span onmouseout="hideTip(event, '7', 86)" onmouseover="showTip(event, '7', 86)" class="fn">state</span> <span onmouseout="hideTip(event, '28', 87)" onmouseover="showTip(event, '28', 87)" class="fn">event</span>
        <span class="c">// do it again with next events</span>
        <span onmouseout="hideTip(event, '34', 88)" onmouseover="showTip(event, '34', 88)" class="fn">fold</span> <span onmouseout="hideTip(event, '37', 89)" onmouseover="showTip(event, '37', 89)" class="fn">newState</span> <span onmouseout="hideTip(event, '36', 90)" onmouseover="showTip(event, '36', 90)" class="fn">rest</span> 
</code></pre>
          <p>
            When the list is empty [] we just return input state. When the list
            is not empty, we deconstruct the list as event :: rest, calling
            event the first Event, and rest the rest of the list. We can then
            compute the new intermediate State using evolve and call fold again
            with this newState and the remaining events rest until we processed
            them all.
          </p>
          <pre
            class="fssnip highlighted"
          ><code lang="fsharp"><span class="k">let</span> <span class="k">rec</span> <span onmouseout="hideTip(event, '38', 91)" onmouseover="showTip(event, '38', 91)" class="fn">fld</span> <span onmouseout="hideTip(event, '39', 92)" onmouseover="showTip(event, '39', 92)" class="fn">f</span> <span onmouseout="hideTip(event, '40', 93)" onmouseover="showTip(event, '40', 93)" class="fn">s</span> <span onmouseout="hideTip(event, '41', 94)" onmouseover="showTip(event, '41', 94)" class="fn">es</span> <span class="o">=</span>
    <span class="k">match</span> <span onmouseout="hideTip(event, '41', 95)" onmouseover="showTip(event, '41', 95)" class="fn">es</span> <span class="k">with</span>
    <span class="pn">|</span><span class="pn">[</span><span class="pn">]</span> <span class="k">-&gt;</span>
        <span onmouseout="hideTip(event, '40', 96)" onmouseover="showTip(event, '40', 96)" class="fn">s</span>
    <span class="pn">|</span> <span onmouseout="hideTip(event, '42', 97)" onmouseover="showTip(event, '42', 97)" class="fn">e</span> <span class="uc">::</span> <span onmouseout="hideTip(event, '41', 98)" onmouseover="showTip(event, '41', 98)" class="fn">es</span> <span class="k">-&gt;</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, '43', 99)" onmouseover="showTip(event, '43', 99)" class="fn">ns</span> <span class="o">=</span> <span onmouseout="hideTip(event, '39', 100)" onmouseover="showTip(event, '39', 100)" class="fn">f</span> <span onmouseout="hideTip(event, '40', 101)" onmouseover="showTip(event, '40', 101)" class="fn">s</span> <span onmouseout="hideTip(event, '42', 102)" onmouseover="showTip(event, '42', 102)" class="fn">e</span>
        <span onmouseout="hideTip(event, '38', 103)" onmouseover="showTip(event, '38', 103)" class="fn">fld</span> <span onmouseout="hideTip(event, '39', 104)" onmouseover="showTip(event, '39', 104)" class="fn">f</span> <span onmouseout="hideTip(event, '43', 105)" onmouseover="showTip(event, '43', 105)" class="fn">ns</span> <span onmouseout="hideTip(event, '41', 106)" onmouseover="showTip(event, '41', 106)" class="fn">es</span>
</code></pre>
          <p>
            Most languages provide libraries containing an implementation of
            this function. It is called fold, left fold or aggregate. It takes a
            list, an aggregation functions, and an initial value. It calls the
            aggregation function for each item in the list with this item and
            previous result. In F# its signature is:
          </p>
          <pre
            class="fssnip highlighted"
          ><code lang="fsharp"><span onmouseout="hideTip(event, '44', 107)" onmouseover="showTip(event, '44', 107)" class="id">List</span><span class="pn">.</span><span onmouseout="hideTip(event, '45', 108)" onmouseover="showTip(event, '45', 108)" class="id">fold</span><span class="pn">:</span> <span class="pn">(</span><span class="id">'</span><span class="id">s</span> <span class="k">-&gt;</span> <span class="id">'</span><span class="id">e</span> <span class="k">-&gt;</span> <span class="id">'</span><span class="id">s</span><span class="pn">)</span> <span class="k">-&gt;</span> <span class="id">'</span><span class="id">s</span> <span class="k">-&gt;</span> <span class="id">'</span><span class="id">e</span> <span onmouseout="hideTip(event, '8', 109)" onmouseover="showTip(event, '8', 109)" class="id">list</span> <span class="k">-&gt;</span> <span class="id">'</span><span class="id">s</span>
</code></pre>
          <p>
            It seems a bit cryptic at fist, but follow with me. The tick “'”
            marks generic types names that can be any actual type. The only
            constraint is that all 's should have the same type, and same thing
            for all 'e. The first argument is a 's -&gt; 'e -&gt; 's a function
            that takes a 's and a 'e and returns a 's. We can notice that it’s
            the same form as our evolve function when replacing 's with State
            and 'e with Event. The second argument is a 's, in our case a State.
            It’s the initial value. The 'e list in our case is the Event list.
            Finally the result is a 's which will be a State.
          </p>
          <p>
            Computing the new state after events when initially in given state
            is simply:
          </p>
          <pre
            class="fssnip highlighted"
          ><code lang="fsharp"><span class="k">let</span> <span class="id">newState</span> <span class="o">=</span> <span onmouseout="hideTip(event, '44', 110)" onmouseover="showTip(event, '44', 110)" class="id">List</span><span class="pn">.</span><span onmouseout="hideTip(event, '45', 111)" onmouseover="showTip(event, '45', 111)" class="id">fold</span> <span class="id">evolve</span> <span class="id">state</span> <span class="id">events</span>
</code></pre>
          <p>
            It will work as expected with no event in the list, in which case it
            will return the input state. It will also process a single event as
            we did by calling the evolve function once.
          </p>
          <p>
            The nice thing it that it is also useful to rebuild the current
            State from Initial State and the full list of Events that happened:
          </p>
          <pre
            class="fssnip highlighted"
          ><code lang="fsharp"><span class="k">let</span> <span class="id">currentState</span> <span class="o">=</span> <span onmouseout="hideTip(event, '44', 112)" onmouseover="showTip(event, '44', 112)" class="id">List</span><span class="pn">.</span><span onmouseout="hideTip(event, '45', 113)" onmouseover="showTip(event, '45', 113)" class="id">fold</span> <span class="id">evolve</span> <span class="id">initialState</span> <span class="id">events</span>
</code></pre>
          <p>
            This is exactly what we’ll need when restarting the system from a
            persisted Event Log.
          </p>
          <h2>
            <a name="Or-not-fold" class="anchor" href="#Or-not-fold"
              >Or not fold</a
            >
          </h2>
          <p>
            While the previous description represents a vast majority of event
            sourced systems, we should still consider a possibility that could
            be useful in some cases.
          </p>
          <p>It would be totally legit to use the following evolve function:</p>
          <pre
            class="fssnip highlighted"
          ><code lang="fsharp"><span class="k">type</span> <span onmouseout="hideTip(event, '26', 114)" onmouseover="showTip(event, '26', 114)" class="id">State</span> <span class="o">=</span> <span onmouseout="hideTip(event, '25', 115)" onmouseover="showTip(event, '25', 115)" class="id">Event</span> <span onmouseout="hideTip(event, '8', 116)" onmouseover="showTip(event, '8', 116)" class="id">list</span>
<span class="k">let</span> <span class="id">initialState</span> <span class="o">=</span> <span class="pn">[</span><span class="pn">]</span>

<span class="k">let</span> <span class="id">evolve</span> <span class="id">state</span> <span class="pn">(</span><span class="id">event</span><span class="pn">:</span> <span onmouseout="hideTip(event, '25', 117)" onmouseover="showTip(event, '25', 117)" class="id">Event</span><span class="pn">)</span> <span class="o">=</span>
    <span onmouseout="hideTip(event, '44', 118)" onmouseover="showTip(event, '44', 118)" class="id">List</span><span class="pn">.</span><span onmouseout="hideTip(event, '46', 119)" onmouseover="showTip(event, '46', 119)" class="id">append</span> <span class="id">state</span>  <span class="pn">[</span><span class="id">event</span><span class="pn">]</span>
</code></pre>
          <p>
            The state would then just be the full list of all events that
            happened before. It would definitely contain all the information
            needed by the decide function:
          </p>
          <pre
            class="fssnip highlighted"
          ><code lang="fsharp"><span class="k">let</span> <span class="id">decide</span> <span class="id">command</span> <span class="pn">(</span><span class="id">state</span><span class="pn">:</span> <span onmouseout="hideTip(event, '25', 120)" onmouseover="showTip(event, '25', 120)" class="id">Event</span> <span onmouseout="hideTip(event, '8', 121)" onmouseover="showTip(event, '8', 121)" class="id">list</span><span class="pn">)</span> <span class="o">=</span>
    <span class="c">(* ... *)</span>
</code></pre>
          <p>
            This decide function can now search through the event list to find
            relevant data to take decision.
          </p>
          <p>
            Once going this direction, the evolve function looks rather useless.
            Folding the state would look like:
          </p>
          <pre
            class="fssnip highlighted"
          ><code lang="fsharp"><span class="id">events</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, '44', 122)" onmouseover="showTip(event, '44', 122)" class="id">List</span><span class="pn">.</span><span onmouseout="hideTip(event, '45', 123)" onmouseover="showTip(event, '45', 123)" class="id">fold</span> <span class="id">evolve</span> <span class="id">initialState</span>
</code></pre>
          <p>Which is equivalent to:</p>
          <pre
            class="fssnip highlighted"
          ><code lang="fsharp"><span class="id">events</span> <span class="o">|&gt;</span> <span onmouseout="hideTip(event, '44', 124)" onmouseover="showTip(event, '44', 124)" class="id">List</span><span class="pn">.</span><span onmouseout="hideTip(event, '45', 125)" onmouseover="showTip(event, '45', 125)" class="id">fold</span> <span class="pn">(</span><span class="k">fun</span> <span class="id">state</span> <span class="id">event</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, '44', 126)" onmouseover="showTip(event, '44', 126)" class="id">List</span><span class="pn">.</span><span onmouseout="hideTip(event, '46', 127)" onmouseover="showTip(event, '46', 127)" class="id">append</span> <span class="id">state</span> <span class="pn">[</span><span class="id">event</span><span class="pn">]</span><span class="pn">)</span> <span class="pn">[</span><span class="pn">]</span>
</code></pre>
          <p>
            This rebuilds an exact copy of the initial events list! We can just
            pass the events list directly to the decide function.
          </p>
          <p>
            In that setting, there is just a decide function with the following
            signature:
          </p>
          <pre
            class="fssnip highlighted"
          ><code lang="fsharp"><span class="id">decide</span><span class="pn">:</span> <span onmouseout="hideTip(event, '24', 128)" onmouseover="showTip(event, '24', 128)" class="id">Command</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, '25', 129)" onmouseover="showTip(event, '25', 129)" class="id">Event</span> <span onmouseout="hideTip(event, '8', 130)" onmouseover="showTip(event, '8', 130)" class="id">list</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, '25', 131)" onmouseover="showTip(event, '25', 131)" class="id">Event</span> <span onmouseout="hideTip(event, '8', 132)" onmouseover="showTip(event, '8', 132)" class="id">list</span>
</code></pre>
          <p>
            A function that takes a command and a list of Events and returns a
            list of new Events.
          </p>
          <p>No need for state, neither of an evolve function.</p>
          <p>
            This can definitely be of use in context with few events, or when
            performance doesn’t come into play.
          </p>
          <p>
            State built by the evolve function is just a projection to compact
            the information contained in the events to make it easier and/or
            faster for the decide function to take decision. If it does not make
            it easier/faster, just use the raw event list.
          </p>
          <p>
            The full list of past Event is the form of the State that contains
            maximal information. This represents the full history.
          </p>
          <h2>
            <a name="Terminal-State" class="anchor" href="#Terminal-State"
              >Terminal State</a
            >
          </h2>
          <p>
            For now our system has an Initial State to start and some functions,
            decide and evolve, to change over time.
          </p>
          <p>
            At first it seems enough, but this is due to one of our typical
            engineer’s bias… We’re very good at setting things up, but bad at
            disposing them. I’ve seen many systems where loads of data remained
            in the system mostly because nobody knew if it was safe to get rid
            of it.
          </p>
          <p>
            This can be seen in the industry at large. Mobiles phones have been
            produced in astronomical numbers before realizing something should
            be done to dispose them properly, and this is still not handled by
            the manufacturers. Same thing for nuclear power plants that have not
            been especially designed to be dismantled.
          </p>
          <p>
            Whether you consider using event sourcing or not, it is best to
            think about it upfront and explicitly design for disposal.
          </p>
          <p>
            Some things have already a definite lifetime. For instance, once an
            order has been shipped and every post shipment tasks have been
            processed, it should never change anymore. Same thing for a card
            game, when the game is over, the result can be taken into account
            for statistics etc, but the game will not change anymore, the decide
            function would never be called.
          </p>
          <p>
            It can have many implications. For instance, if you keep state in
            memory for fast response, you can now unload it to save space. It
            also means that the history can be archived or deleted depending on
            your retention needs.
          </p>
          <p>
            Removing old data from your system (or at least moving it to a
            colder area) will keep your hot area slim and far more manageable.
            This is an efficient way to lower costs and simplify updates and
            migrations.
          </p>
          <p>
            Even parts that have a definite life time are sometimes hard to
            dispose. For instance, what happens when an order shipment was lost
            and there’s nobody to reclaim it, or where all players in a game
            left the table to never return? It could lead to data dangling
            forever. To avoid this, you have to determine a policy with domain
            experts. It probably already exists in the domain, for instance,
            lost shipment cases are considered closed after 1 month in absence
            of reclamation. Or you could establish a new one. For a card game,
            players have a maximum time to play. It could range from a few hours
            for a real time game, to a few weeks for turn by turn. A process
            could be put in place to alert users, but after this delay a command
            is sent to the system to close it, and it then transitions to a
            terminal state.
          </p>
          <p>
            The question is more tricky for systems whose behavior can span
            continuously over many years with no foreseeable end. But this is
            something that has already been solved by accountants. The
            accounting records for a company can easily span decades. The
            current balance is impacted by all the records since the beginning,
            but it would be impractical to recompute everything from the first
            record. Especially after a few year the relevance of records for the
            current state drops significantly. This is where accountants define
            an accounting period. At the end of the period, a book balance is
            computed, reconciled with the bank. The current book is closed and a
            new one is opened, starting from previous book balance. This way
            once a book is closed, it is never changed anymore and can be
            archived for reference. If an error is found after closing the book,
            a compensation is recorded in the current book.
          </p>
          <p>
            It is highly advised to put such mechanisms in place for your own
            system, especially if you keep data over time, like saving events.
            Even if storage is going cheaper over time, your system will evolve,
            and since data that is considered hot can change at any time, it
            must be migrated and evolved in a transactional or high
            availability, zero downtime way. This places a high burden on
            operations. For streams of events, recomputing current state with
            such strategy will be done in a time dependent on your business
            size. Without it it will be dependent on both business size and time
            since it started (it’s actually an integral of business size over
            time).
          </p>
          <p>
            Once we’ve defined a condition for disposability, we can implement
            it with a simple function:
          </p>
          <pre
            class="fssnip highlighted"
          ><code lang="fsharp"><span class="id">IsTerminal</span><span class="pn">:</span> <span class="id">'</span><span class="id">state</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, '47', 133)" onmouseover="showTip(event, '47', 133)" class="id">bool</span>
</code></pre>
          <p>
            This function takes a state, and returns a bool indicating if it is
            a terminal state. I really encourage you to make it part of your
            design to avoid maintenance problems later.
          </p>
          <h2><a name="Decider" class="anchor" href="#Decider">Decider</a></h2>
          <p>
            We’ve seen that State and the evolve function are just an
            optimization to compact information, to avoid going through the full
            list of Events at each call of the decide function. And this clearly
            indicates that the most important part in what we’ve seen so far is
            the decide function.
          </p>
          <p>
            We will call a Decider the combination of the seven elements we’ve
            identified so far:
          </p>
          <ul>
            <li>
              A Command type that represents all commands that can be submitted
              to the Decider
            </li>
            <li>
              An Event type that represents all events that can be produced by
              the Decider
            </li>
            <li>
              A State type that represents all possible states of the Decider
              (can just be the list of all events)
            </li>
            <li>
              An Initial State that is the state of the Decider before anything
              happened to it
            </li>
            <li>
              A decide function that takes a Command and a State and returns a
              list of Event
            </li>
            <li>
              An evolve function that takes a State and an Event and returns a
              new State
            </li>
            <li>
              An isTerminal function that takes a State and returns a boolean
              value
            </li>
          </ul>
          <p>In F# this can be modeled as:</p>
          <pre
            class="fssnip highlighted"
          ><code lang="fsharp"><span class="k">type</span> <span onmouseout="hideTip(event, '48', 134)" onmouseover="showTip(event, '48', 134)" class="rt">Decider</span><span class="pn">&lt;</span><span class="ta">'</span><span class="id">c</span><span class="pn">,</span><span class="ta">'</span><span class="id">e</span><span class="pn">,</span><span class="ta">'</span><span class="id">s</span><span class="pn">&gt;</span> <span class="o">=</span> 
    <span class="pn">{</span> <span onmouseout="hideTip(event, '49', 135)" onmouseover="showTip(event, '49', 135)" class="fn">decide</span><span class="pn">:</span> <span class="ta">'</span><span class="id">c</span> <span class="k">-&gt;</span> <span class="ta">'</span><span class="id">s</span> <span class="k">-&gt;</span> <span class="ta">'</span><span class="id">e</span> <span onmouseout="hideTip(event, '8', 136)" onmouseover="showTip(event, '8', 136)" class="rt">list</span>
      <span onmouseout="hideTip(event, '50', 137)" onmouseover="showTip(event, '50', 137)" class="fn">evolve</span><span class="pn">:</span> <span class="ta">'</span><span class="id">s</span> <span class="k">-&gt;</span> <span class="ta">'</span><span class="id">e</span> <span class="k">-&gt;</span> <span class="ta">'</span><span class="id">s</span>
      <span onmouseout="hideTip(event, '51', 138)" onmouseover="showTip(event, '51', 138)" class="prop">initialState</span><span class="pn">:</span> <span class="ta">'</span><span class="id">s</span>
      <span onmouseout="hideTip(event, '52', 139)" onmouseover="showTip(event, '52', 139)" class="fn">isTerminal</span><span class="pn">:</span> <span class="ta">'</span><span class="id">s</span> <span class="k">-&gt;</span> <span onmouseout="hideTip(event, '20', 140)" onmouseover="showTip(event, '20', 140)" class="vt">bool</span> <span class="pn">}</span>
</code></pre>
          <p>
            The Decider is a conceptual way to think about systems that change
            in time. A concepty interface between the Application layer and the
            Domain code. It has the advantage to create extremely low friction
            between them.
          </p>
          <h2>
            <a name="Run-in-memory" class="anchor" href="#Run-in-memory"
              >Run in memory</a
            >
          </h2>
          <p>
            We can easily make a decider run in memory on a mutable State
            variable:
          </p>
          <pre
            class="fssnip highlighted"
          ><code lang="fsharp"><span class="k">module</span> <span class="m">InMemory</span> <span class="o">=</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, '53', 141)" onmouseover="showTip(event, '53', 141)" class="fn">start</span> <span class="pn">(</span><span onmouseout="hideTip(event, '54', 142)" onmouseover="showTip(event, '54', 142)" class="fn">decider</span><span class="pn">:</span> <span onmouseout="hideTip(event, '48', 143)" onmouseover="showTip(event, '48', 143)" class="rt">Decider</span><span class="pn">&lt;</span><span class="ta">'</span><span class="id">c</span><span class="pn">,</span><span class="ta">'</span><span class="id">e</span><span class="pn">,</span><span class="ta">'</span><span class="id">s</span><span class="pn">&gt;</span><span class="pn">)</span> <span class="o">=</span>
        <span class="k">let</span> <span class="k">mutable</span> <span onmouseout="hideTip(event, '55', 144)" onmouseover="showTip(event, '55', 144)" class="mv">state</span> <span class="o">=</span> <span onmouseout="hideTip(event, '54', 145)" onmouseover="showTip(event, '54', 145)" class="fn">decider</span><span class="pn">.</span><span onmouseout="hideTip(event, '51', 146)" onmouseover="showTip(event, '51', 146)" class="id">initialState</span>

        <span class="k">fun</span> <span class="pn">(</span><span onmouseout="hideTip(event, '56', 147)" onmouseover="showTip(event, '56', 147)" class="fn">command</span><span class="pn">:</span> <span class="ta">'</span><span class="id">c</span><span class="pn">)</span> <span class="k">-&gt;</span>
            <span class="k">let</span> <span onmouseout="hideTip(event, '57', 148)" onmouseover="showTip(event, '57', 148)" class="fn">events</span> <span class="o">=</span> <span onmouseout="hideTip(event, '54', 149)" onmouseover="showTip(event, '54', 149)" class="fn">decider</span><span class="pn">.</span><span onmouseout="hideTip(event, '49', 150)" onmouseover="showTip(event, '49', 150)" class="id">decide</span> <span onmouseout="hideTip(event, '56', 151)" onmouseover="showTip(event, '56', 151)" class="fn">command</span> <span onmouseout="hideTip(event, '55', 152)" onmouseover="showTip(event, '55', 152)" class="mv">state</span>
            <span onmouseout="hideTip(event, '55', 153)" onmouseover="showTip(event, '55', 153)" class="mv">state</span> <span class="k">&lt;-</span> <span onmouseout="hideTip(event, '44', 154)" onmouseover="showTip(event, '44', 154)" class="m">List</span><span class="pn">.</span><span onmouseout="hideTip(event, '45', 155)" onmouseover="showTip(event, '45', 155)" class="id">fold</span> <span onmouseout="hideTip(event, '54', 156)" onmouseover="showTip(event, '54', 156)" class="fn">decider</span><span class="pn">.</span><span onmouseout="hideTip(event, '50', 157)" onmouseover="showTip(event, '50', 157)" class="id">evolve</span> <span onmouseout="hideTip(event, '55', 158)" onmouseover="showTip(event, '55', 158)" class="mv">state</span> <span onmouseout="hideTip(event, '57', 159)" onmouseover="showTip(event, '57', 159)" class="fn">events</span>
            <span onmouseout="hideTip(event, '57', 160)" onmouseover="showTip(event, '57', 160)" class="fn">events</span>
</code></pre>
          <p>
            For any decider we can now call the start method function. It will
            return a function which given a command, returns the list of Events
            and is ready for the next command.
          </p>
          <h2>
            <a name="Run-on-a-database" class="anchor" href="#Run-on-a-database"
              >Run on a database</a
            >
          </h2>
          <p>
            The previous implementation is not persistent, and will lose any
            state once closed. We can persist state in a database like any
            classic application:
          </p>
          <pre
            class="fssnip highlighted"
          ><code lang="fsharp"><span class="k">module</span> <span class="m">WithPersistence</span> <span class="o">=</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, '63', 169)" onmouseover="showTip(event, '63', 169)" class="fn">start</span> <span class="pn">(</span><span onmouseout="hideTip(event, '54', 170)" onmouseover="showTip(event, '54', 170)" class="fn">decider</span><span class="pn">:</span> <span onmouseout="hideTip(event, '48', 171)" onmouseover="showTip(event, '48', 171)" class="rt">Decider</span><span class="pn">&lt;</span><span class="ta">'</span><span class="id">c</span><span class="pn">,</span><span class="ta">'</span><span class="id">e</span><span class="pn">,</span><span class="ta">'</span><span class="id">s</span><span class="pn">&gt;</span><span class="pn">)</span> <span class="o">=</span>
        <span class="k">fun</span> <span onmouseout="hideTip(event, '59', 172)" onmouseover="showTip(event, '59', 172)" class="fn">id</span> <span class="pn">(</span><span onmouseout="hideTip(event, '56', 173)" onmouseover="showTip(event, '56', 173)" class="fn">command</span><span class="pn">:</span> <span class="ta">'</span><span class="id">c</span><span class="pn">)</span> <span class="k">-&gt;</span>
            <span class="c">// load state from database</span>
            <span class="k">let</span> <span onmouseout="hideTip(event, '61', 174)" onmouseover="showTip(event, '61', 174)" class="fn">state</span> <span class="o">=</span> <span onmouseout="hideTip(event, '64', 175)" onmouseover="showTip(event, '64', 175)" class="m">Storage</span><span class="pn">.</span><span onmouseout="hideTip(event, '58', 176)" onmouseover="showTip(event, '58', 176)" class="id">loadState</span><span class="pn">(</span><span onmouseout="hideTip(event, '59', 177)" onmouseover="showTip(event, '59', 177)" class="fn">id</span><span class="pn">)</span>
            <span class="c">// this is the decision</span>
            <span class="k">let</span> <span onmouseout="hideTip(event, '57', 178)" onmouseover="showTip(event, '57', 178)" class="fn">events</span> <span class="o">=</span> <span onmouseout="hideTip(event, '54', 179)" onmouseover="showTip(event, '54', 179)" class="fn">decider</span><span class="pn">.</span><span onmouseout="hideTip(event, '49', 180)" onmouseover="showTip(event, '49', 180)" class="id">decide</span> <span onmouseout="hideTip(event, '56', 181)" onmouseover="showTip(event, '56', 181)" class="fn">command</span> <span onmouseout="hideTip(event, '61', 182)" onmouseover="showTip(event, '61', 182)" class="fn">state</span>
            <span class="c">// compute new state</span>
            <span class="k">let</span> <span onmouseout="hideTip(event, '65', 183)" onmouseover="showTip(event, '65', 183)" class="fn">newState</span> <span class="o">=</span> <span onmouseout="hideTip(event, '44', 184)" onmouseover="showTip(event, '44', 184)" class="m">List</span><span class="pn">.</span><span onmouseout="hideTip(event, '45', 185)" onmouseover="showTip(event, '45', 185)" class="id">fold</span> <span onmouseout="hideTip(event, '54', 186)" onmouseover="showTip(event, '54', 186)" class="fn">decider</span><span class="pn">.</span><span onmouseout="hideTip(event, '50', 187)" onmouseover="showTip(event, '50', 187)" class="id">evolve</span> <span onmouseout="hideTip(event, '61', 188)" onmouseover="showTip(event, '61', 188)" class="fn">state</span> <span onmouseout="hideTip(event, '57', 189)" onmouseover="showTip(event, '57', 189)" class="fn">events</span>
            <span class="c">// save state in database</span>
            <span onmouseout="hideTip(event, '64', 190)" onmouseover="showTip(event, '64', 190)" class="m">Storage</span><span class="pn">.</span><span onmouseout="hideTip(event, '60', 191)" onmouseover="showTip(event, '60', 191)" class="id">saveState</span><span class="pn">(</span><span onmouseout="hideTip(event, '59', 192)" onmouseover="showTip(event, '59', 192)" class="fn">id</span><span class="pn">,</span> <span onmouseout="hideTip(event, '65', 193)" onmouseover="showTip(event, '65', 193)" class="fn">newState</span><span class="pn">)</span>
            <span onmouseout="hideTip(event, '57', 194)" onmouseover="showTip(event, '57', 194)" class="fn">events</span>
</code></pre>
          <p>
            This version is simple but can be dangerous if the state can be
            modified concurrently. If operations are never concurrent, this code
            is simple and perfectly fine.
          </p>
          <p>
            It is then easily protected using an etag. This is usually a string
            returned by the database that is modified on each change. The
            database can check that the provided etag is matching current etag
            before saving the data.
          </p>
          <pre
            class="fssnip highlighted"
          ><code lang="fsharp"><span class="k">module</span> <span class="m">PersistenceWithEtag</span> <span class="o">=</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, '63', 208)" onmouseover="showTip(event, '63', 208)" class="fn">start</span> <span class="pn">(</span><span onmouseout="hideTip(event, '54', 209)" onmouseover="showTip(event, '54', 209)" class="fn">decider</span><span class="pn">:</span> <span onmouseout="hideTip(event, '48', 210)" onmouseover="showTip(event, '48', 210)" class="rt">Decider</span><span class="pn">&lt;</span><span class="ta">'</span><span class="id">c</span><span class="pn">,</span><span class="ta">'</span><span class="id">e</span><span class="pn">,</span><span class="ta">'</span><span class="id">s</span><span class="pn">&gt;</span><span class="pn">)</span> <span class="o">=</span>
        <span class="k">fun</span> <span onmouseout="hideTip(event, '59', 211)" onmouseover="showTip(event, '59', 211)" class="fn">id</span> <span class="pn">(</span><span onmouseout="hideTip(event, '56', 212)" onmouseover="showTip(event, '56', 212)" class="fn">command</span><span class="pn">:</span> <span class="ta">'</span><span class="id">c</span><span class="pn">)</span> <span class="k">-&gt;</span>
            <span class="k">let</span> <span class="k">rec</span> <span onmouseout="hideTip(event, '70', 213)" onmouseover="showTip(event, '70', 213)" class="fn">handle</span><span class="pn">(</span><span class="pn">)</span> <span class="o">=</span>
                <span class="c">// load state and etag</span>
                <span class="k">let</span> <span onmouseout="hideTip(event, '69', 214)" onmouseover="showTip(event, '69', 214)" class="fn">etag</span><span class="pn">,</span> <span onmouseout="hideTip(event, '61', 215)" onmouseover="showTip(event, '61', 215)" class="fn">state</span> <span class="o">=</span> <span onmouseout="hideTip(event, '71', 216)" onmouseover="showTip(event, '71', 216)" class="m">StorageWithEtag</span><span class="pn">.</span><span onmouseout="hideTip(event, '67', 217)" onmouseover="showTip(event, '67', 217)" class="id">loadState</span><span class="pn">(</span><span onmouseout="hideTip(event, '59', 218)" onmouseover="showTip(event, '59', 218)" class="fn">id</span><span class="pn">)</span>
                <span class="c">// this is the decision</span>
                <span class="k">let</span> <span onmouseout="hideTip(event, '57', 219)" onmouseover="showTip(event, '57', 219)" class="fn">events</span> <span class="o">=</span> <span onmouseout="hideTip(event, '54', 220)" onmouseover="showTip(event, '54', 220)" class="fn">decider</span><span class="pn">.</span><span onmouseout="hideTip(event, '49', 221)" onmouseover="showTip(event, '49', 221)" class="id">decide</span> <span onmouseout="hideTip(event, '56', 222)" onmouseover="showTip(event, '56', 222)" class="fn">command</span> <span onmouseout="hideTip(event, '61', 223)" onmouseover="showTip(event, '61', 223)" class="fn">state</span>
                <span class="c">// compute the new state</span>
                <span class="k">let</span> <span onmouseout="hideTip(event, '65', 224)" onmouseover="showTip(event, '65', 224)" class="fn">newState</span> <span class="o">=</span> <span onmouseout="hideTip(event, '44', 225)" onmouseover="showTip(event, '44', 225)" class="m">List</span><span class="pn">.</span><span onmouseout="hideTip(event, '45', 226)" onmouseover="showTip(event, '45', 226)" class="id">fold</span> <span onmouseout="hideTip(event, '54', 227)" onmouseover="showTip(event, '54', 227)" class="fn">decider</span><span class="pn">.</span><span onmouseout="hideTip(event, '50', 228)" onmouseover="showTip(event, '50', 228)" class="id">evolve</span> <span onmouseout="hideTip(event, '61', 229)" onmouseover="showTip(event, '61', 229)" class="fn">state</span> <span onmouseout="hideTip(event, '57', 230)" onmouseover="showTip(event, '57', 230)" class="fn">events</span>
                <span class="c">// try to save, checking the state still match etag</span>
                <span class="k">if</span> <span onmouseout="hideTip(event, '71', 231)" onmouseover="showTip(event, '71', 231)" class="m">StorageWithEtag</span><span class="pn">.</span><span onmouseout="hideTip(event, '68', 232)" onmouseover="showTip(event, '68', 232)" class="id">trySaveState</span><span class="pn">(</span><span onmouseout="hideTip(event, '59', 233)" onmouseover="showTip(event, '59', 233)" class="fn">id</span><span class="pn">,</span> <span onmouseout="hideTip(event, '69', 234)" onmouseover="showTip(event, '69', 234)" class="fn">etag</span><span class="pn">,</span> <span onmouseout="hideTip(event, '65', 235)" onmouseover="showTip(event, '65', 235)" class="fn">newState</span><span class="pn">)</span> <span class="k">then</span>
                    <span onmouseout="hideTip(event, '57', 236)" onmouseover="showTip(event, '57', 236)" class="fn">events</span>
                <span class="k">else</span>
                    <span onmouseout="hideTip(event, '70', 237)" onmouseover="showTip(event, '70', 237)" class="fn">handle</span><span class="pn">(</span><span class="pn">)</span>
            <span onmouseout="hideTip(event, '70', 238)" onmouseover="showTip(event, '70', 238)" class="fn">handle</span><span class="pn">(</span><span class="pn">)</span>            
</code></pre>
          <p>
            This version will stubbornly retry until we avoid the concurrency
            problem.
          </p>
          <p>
            It is also possible to keep state in memory to avoid loading state
            on each call. However in case of conflict, we will reload the state
            as well as the current ETag
          </p>
          <pre
            class="fssnip highlighted"
          ><code lang="fsharp"><span class="k">module</span> <span class="m">PersistenceWithEtagAndRetry</span> <span class="o">=</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, '74', 251)" onmouseover="showTip(event, '74', 251)" class="fn">start</span> <span class="pn">(</span><span onmouseout="hideTip(event, '54', 252)" onmouseover="showTip(event, '54', 252)" class="fn">decider</span><span class="pn">:</span> <span onmouseout="hideTip(event, '48', 253)" onmouseover="showTip(event, '48', 253)" class="rt">Decider</span><span class="pn">&lt;</span><span class="ta">'</span><span class="id">c</span><span class="pn">,</span><span class="ta">'</span><span class="id">e</span><span class="pn">,</span><span class="ta">'</span><span class="id">s</span><span class="pn">&gt;</span><span class="pn">)</span> <span class="o">=</span>
        <span class="c">// load initial state</span>
        <span class="k">let</span> <span class="k">mutable</span> <span onmouseout="hideTip(event, '75', 254)" onmouseover="showTip(event, '75', 254)" class="mv">etagAndState</span> <span class="o">=</span> <span onmouseout="hideTip(event, '76', 255)" onmouseover="showTip(event, '76', 255)" class="m">StorageWithEtagAndRetry</span><span class="pn">.</span><span onmouseout="hideTip(event, '67', 256)" onmouseover="showTip(event, '67', 256)" class="id">loadState</span><span class="pn">(</span><span onmouseout="hideTip(event, '77', 257)" onmouseover="showTip(event, '77', 257)" class="fn">id</span><span class="pn">)</span>
        <span class="k">fun</span> <span onmouseout="hideTip(event, '59', 258)" onmouseover="showTip(event, '59', 258)" class="fn">id</span> <span class="pn">(</span><span onmouseout="hideTip(event, '56', 259)" onmouseover="showTip(event, '56', 259)" class="fn">command</span><span class="pn">:</span> <span class="ta">'</span><span class="id">c</span><span class="pn">)</span> <span class="k">-&gt;</span>
            <span class="k">let</span> <span class="k">rec</span> <span onmouseout="hideTip(event, '78', 260)" onmouseover="showTip(event, '78', 260)" class="fn">handle</span> <span class="pn">(</span><span onmouseout="hideTip(event, '69', 261)" onmouseover="showTip(event, '69', 261)" class="fn">etag</span><span class="pn">,</span> <span onmouseout="hideTip(event, '79', 262)" onmouseover="showTip(event, '79', 262)" class="fn">state</span><span class="pn">)</span> <span class="o">=</span>
                <span class="k">let</span> <span class="pn">(</span><span onmouseout="hideTip(event, '69', 263)" onmouseover="showTip(event, '69', 263)" class="fn">etag</span><span class="pn">,</span> <span onmouseout="hideTip(event, '61', 264)" onmouseover="showTip(event, '61', 264)" class="fn">state</span><span class="pn">)</span> <span class="o">=</span> <span onmouseout="hideTip(event, '75', 265)" onmouseover="showTip(event, '75', 265)" class="mv">etagAndState</span>
                <span class="c">// this is the decision</span>
                <span class="k">let</span> <span onmouseout="hideTip(event, '57', 266)" onmouseover="showTip(event, '57', 266)" class="fn">events</span> <span class="o">=</span> <span onmouseout="hideTip(event, '54', 267)" onmouseover="showTip(event, '54', 267)" class="fn">decider</span><span class="pn">.</span><span onmouseout="hideTip(event, '49', 268)" onmouseover="showTip(event, '49', 268)" class="id">decide</span> <span onmouseout="hideTip(event, '56', 269)" onmouseover="showTip(event, '56', 269)" class="fn">command</span> <span onmouseout="hideTip(event, '61', 270)" onmouseover="showTip(event, '61', 270)" class="fn">state</span>
                <span class="c">// compute new state</span>
                <span class="k">let</span> <span onmouseout="hideTip(event, '65', 271)" onmouseover="showTip(event, '65', 271)" class="fn">newState</span> <span class="o">=</span> <span onmouseout="hideTip(event, '44', 272)" onmouseover="showTip(event, '44', 272)" class="m">List</span><span class="pn">.</span><span onmouseout="hideTip(event, '45', 273)" onmouseover="showTip(event, '45', 273)" class="id">fold</span> <span onmouseout="hideTip(event, '54', 274)" onmouseover="showTip(event, '54', 274)" class="fn">decider</span><span class="pn">.</span><span onmouseout="hideTip(event, '50', 275)" onmouseover="showTip(event, '50', 275)" class="id">evolve</span> <span onmouseout="hideTip(event, '61', 276)" onmouseover="showTip(event, '61', 276)" class="fn">state</span> <span onmouseout="hideTip(event, '57', 277)" onmouseover="showTip(event, '57', 277)" class="fn">events</span>
                <span class="c">// try to save, checking the state still match etag</span>
                <span class="k">match</span> <span onmouseout="hideTip(event, '76', 278)" onmouseover="showTip(event, '76', 278)" class="m">StorageWithEtagAndRetry</span><span class="pn">.</span><span onmouseout="hideTip(event, '72', 279)" onmouseover="showTip(event, '72', 279)" class="id">trySaveState</span><span class="pn">(</span><span onmouseout="hideTip(event, '59', 280)" onmouseover="showTip(event, '59', 280)" class="fn">id</span><span class="pn">,</span> <span onmouseout="hideTip(event, '69', 281)" onmouseover="showTip(event, '69', 281)" class="fn">etag</span><span class="pn">,</span> <span onmouseout="hideTip(event, '61', 282)" onmouseover="showTip(event, '61', 282)" class="fn">state</span><span class="pn">)</span>  <span class="k">with</span>
                <span class="pn">|</span> <span onmouseout="hideTip(event, '80', 283)" onmouseover="showTip(event, '80', 283)" class="uc">Some</span> <span onmouseout="hideTip(event, '81', 284)" onmouseover="showTip(event, '81', 284)" class="fn">newEtag</span> <span class="k">-&gt;</span>
                    <span class="c">// state has been saved</span>
                    <span onmouseout="hideTip(event, '75', 285)" onmouseover="showTip(event, '75', 285)" class="mv">etagAndState</span> <span class="k">&lt;-</span> <span class="pn">(</span><span onmouseout="hideTip(event, '81', 286)" onmouseover="showTip(event, '81', 286)" class="fn">newEtag</span><span class="pn">,</span> <span onmouseout="hideTip(event, '65', 287)" onmouseover="showTip(event, '65', 287)" class="fn">newState</span><span class="pn">)</span>
                    <span onmouseout="hideTip(event, '57', 288)" onmouseover="showTip(event, '57', 288)" class="fn">events</span>
                <span class="pn">|</span> <span onmouseout="hideTip(event, '82', 289)" onmouseover="showTip(event, '82', 289)" class="uc">None</span> <span class="k">-&gt;</span>
                    <span class="c">// a conflict occurred, reload etag and state</span>
                    <span class="c">// from database and retry</span>
                    <span onmouseout="hideTip(event, '78', 290)" onmouseover="showTip(event, '78', 290)" class="fn">handle</span> <span class="pn">(</span><span onmouseout="hideTip(event, '76', 291)" onmouseover="showTip(event, '76', 291)" class="m">StorageWithEtagAndRetry</span><span class="pn">.</span><span onmouseout="hideTip(event, '67', 292)" onmouseover="showTip(event, '67', 292)" class="id">loadState</span><span class="pn">(</span><span onmouseout="hideTip(event, '59', 293)" onmouseover="showTip(event, '59', 293)" class="fn">id</span><span class="pn">)</span><span class="pn">)</span>
            <span onmouseout="hideTip(event, '78', 294)" onmouseover="showTip(event, '78', 294)" class="fn">handle</span> <span onmouseout="hideTip(event, '75', 295)" onmouseover="showTip(event, '75', 295)" class="mv">etagAndState</span>
</code></pre>
          <p>
            It is possible to also store events in an Event Store, but still
            load/save state on each call. In this case, events can be used to
            recompute current state when a refactoring change its shape. Instead
            of migrating old state version to new version using a one time
            script, you can fold all saved events through the evolve function
            and save state with this new version. This is actually the
            equivalent of saving a <a href="#Snapshots">snapshot</a> on each
            call.
          </p>
          <h2>
            <a
              name="Run-on-an-event-store"
              class="anchor"
              href="#Run-on-an-event-store"
              >Run on an event store</a
            >
          </h2>
          <p>It can also easily be implemented using an event store</p>
          <pre
            class="fssnip highlighted"
          ><code lang="fsharp"><span class="k">module</span> <span class="m">WithEventStore</span> <span class="o">=</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, '89', 309)" onmouseover="showTip(event, '89', 309)" class="fn">start</span> <span class="pn">(</span><span onmouseout="hideTip(event, '54', 310)" onmouseover="showTip(event, '54', 310)" class="fn">decider</span><span class="pn">:</span> <span onmouseout="hideTip(event, '48', 311)" onmouseover="showTip(event, '48', 311)" class="rt">Decider</span><span class="pn">&lt;</span><span class="ta">'</span><span class="id">c</span><span class="pn">,</span><span class="ta">'</span><span class="id">e</span><span class="pn">,</span><span class="ta">'</span><span class="id">s</span><span class="pn">&gt;</span><span class="pn">)</span> <span class="o">=</span>
        <span class="k">fun</span> <span onmouseout="hideTip(event, '86', 312)" onmouseover="showTip(event, '86', 312)" class="fn">stream</span> <span class="pn">(</span><span onmouseout="hideTip(event, '56', 313)" onmouseover="showTip(event, '56', 313)" class="fn">command</span><span class="pn">:</span> <span class="ta">'</span><span class="id">c</span><span class="pn">)</span> <span class="k">-&gt;</span>
            <span class="c">// load all past events to compute current state</span>
            <span class="k">let</span> <span onmouseout="hideTip(event, '61', 314)" onmouseover="showTip(event, '61', 314)" class="fn">state</span> <span class="o">=</span> 
                <span onmouseout="hideTip(event, '90', 315)" onmouseover="showTip(event, '90', 315)" class="m">EventStore</span><span class="pn">.</span><span onmouseout="hideTip(event, '85', 316)" onmouseover="showTip(event, '85', 316)" class="id">loadEvents</span><span class="pn">(</span><span onmouseout="hideTip(event, '86', 317)" onmouseover="showTip(event, '86', 317)" class="fn">stream</span><span class="pn">,</span> <span class="n">0</span><span class="pn">)</span>
                <span class="o">|&gt;</span> <span onmouseout="hideTip(event, '44', 318)" onmouseover="showTip(event, '44', 318)" class="m">List</span><span class="pn">.</span><span onmouseout="hideTip(event, '45', 319)" onmouseover="showTip(event, '45', 319)" class="id">fold</span> <span onmouseout="hideTip(event, '54', 320)" onmouseover="showTip(event, '54', 320)" class="fn">decider</span><span class="pn">.</span><span onmouseout="hideTip(event, '50', 321)" onmouseover="showTip(event, '50', 321)" class="id">evolve</span> <span onmouseout="hideTip(event, '54', 322)" onmouseover="showTip(event, '54', 322)" class="fn">decider</span><span class="pn">.</span><span onmouseout="hideTip(event, '51', 323)" onmouseover="showTip(event, '51', 323)" class="id">initialState</span>
            <span class="c">// get events from the decision</span>
            <span class="k">let</span> <span onmouseout="hideTip(event, '57', 324)" onmouseover="showTip(event, '57', 324)" class="fn">events</span> <span class="o">=</span> <span onmouseout="hideTip(event, '54', 325)" onmouseover="showTip(event, '54', 325)" class="fn">decider</span><span class="pn">.</span><span onmouseout="hideTip(event, '49', 326)" onmouseover="showTip(event, '49', 326)" class="id">decide</span> <span onmouseout="hideTip(event, '56', 327)" onmouseover="showTip(event, '56', 327)" class="fn">command</span> <span onmouseout="hideTip(event, '61', 328)" onmouseover="showTip(event, '61', 328)" class="fn">state</span>
            <span class="c">// append events to stream</span>
            <span onmouseout="hideTip(event, '90', 329)" onmouseover="showTip(event, '90', 329)" class="m">EventStore</span><span class="pn">.</span><span onmouseout="hideTip(event, '88', 330)" onmouseover="showTip(event, '88', 330)" class="id">appendEvents</span><span class="pn">(</span><span onmouseout="hideTip(event, '86', 331)" onmouseover="showTip(event, '86', 331)" class="fn">stream</span><span class="pn">,</span> <span onmouseout="hideTip(event, '57', 332)" onmouseover="showTip(event, '57', 332)" class="fn">events</span><span class="pn">)</span>
            <span onmouseout="hideTip(event, '57', 333)" onmouseover="showTip(event, '57', 333)" class="fn">events</span>
</code></pre>
          <p>
            This version is reloading all the events from the beginning on each
            command. This is totally acceptable for short streams. Since events
            are usually small in size, loading less that 100 events is very fast
            and folding them, almost instant (think of it as a loop of 100
            iterations that do a few basic operations).
          </p>
          <p>
            As for the database backed version, we can protect it against
            concurrent appends to the stream. Here we use stream version which
            is usually provided by the Event Store. The appendEvents function
            now takes an expected version and will fail if the stream version is
            not matching. In case it is not matching it will return the new
            version as well as events that have been appended since.
          </p>
          <pre
            class="fssnip highlighted"
          ><code lang="fsharp"><span class="k">module</span> <span class="m">WithEventStoreAndVersion</span> <span class="o">=</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, '89', 350)" onmouseover="showTip(event, '89', 350)" class="fn">start</span> <span class="pn">(</span><span onmouseout="hideTip(event, '54', 351)" onmouseover="showTip(event, '54', 351)" class="fn">decider</span><span class="pn">:</span> <span onmouseout="hideTip(event, '48', 352)" onmouseover="showTip(event, '48', 352)" class="rt">Decider</span><span class="pn">&lt;</span><span class="ta">'</span><span class="id">c</span><span class="pn">,</span><span class="ta">'</span><span class="id">e</span><span class="pn">,</span><span class="ta">'</span><span class="id">s</span><span class="pn">&gt;</span><span class="pn">)</span> <span class="o">=</span>
        <span class="k">fun</span> <span onmouseout="hideTip(event, '86', 353)" onmouseover="showTip(event, '86', 353)" class="fn">stream</span> <span class="pn">(</span><span onmouseout="hideTip(event, '56', 354)" onmouseover="showTip(event, '56', 354)" class="fn">command</span><span class="pn">:</span> <span class="ta">'</span><span class="id">c</span><span class="pn">)</span> <span class="k">-&gt;</span>
            <span class="k">let</span> <span class="k">rec</span> <span onmouseout="hideTip(event, '95', 355)" onmouseover="showTip(event, '95', 355)" class="fn">handle</span> <span onmouseout="hideTip(event, '87', 356)" onmouseover="showTip(event, '87', 356)" class="fn">version</span> <span onmouseout="hideTip(event, '61', 357)" onmouseover="showTip(event, '61', 357)" class="fn">state</span> <span class="o">=</span>
                <span class="c">// get events from decision</span>
                <span class="k">let</span> <span onmouseout="hideTip(event, '57', 358)" onmouseover="showTip(event, '57', 358)" class="fn">events</span> <span class="o">=</span> <span onmouseout="hideTip(event, '54', 359)" onmouseover="showTip(event, '54', 359)" class="fn">decider</span><span class="pn">.</span><span onmouseout="hideTip(event, '49', 360)" onmouseover="showTip(event, '49', 360)" class="id">decide</span> <span onmouseout="hideTip(event, '56', 361)" onmouseover="showTip(event, '56', 361)" class="fn">command</span> <span onmouseout="hideTip(event, '61', 362)" onmouseover="showTip(event, '61', 362)" class="fn">state</span>
                <span class="k">match</span> <span onmouseout="hideTip(event, '96', 363)" onmouseover="showTip(event, '96', 363)" class="m">EventStoreWithVersion</span><span class="pn">.</span><span onmouseout="hideTip(event, '92', 364)" onmouseover="showTip(event, '92', 364)" class="id">tryAppendEvents</span><span class="pn">(</span><span onmouseout="hideTip(event, '86', 365)" onmouseover="showTip(event, '86', 365)" class="fn">stream</span><span class="pn">,</span> <span onmouseout="hideTip(event, '87', 366)" onmouseover="showTip(event, '87', 366)" class="fn">version</span><span class="pn">,</span> <span onmouseout="hideTip(event, '57', 367)" onmouseover="showTip(event, '57', 367)" class="fn">events</span><span class="pn">)</span> <span class="k">with</span>
                <span class="pn">|</span> <span onmouseout="hideTip(event, '97', 368)" onmouseover="showTip(event, '97', 368)" class="uc">Ok</span> <span onmouseout="hideTip(event, '87', 369)" onmouseover="showTip(event, '87', 369)" class="fn">version</span> <span class="k">-&gt;</span>
                    <span class="c">// save succeeded, we can return events</span>
                    <span onmouseout="hideTip(event, '57', 370)" onmouseover="showTip(event, '57', 370)" class="fn">events</span>
                <span class="pn">|</span> <span onmouseout="hideTip(event, '98', 371)" onmouseover="showTip(event, '98', 371)" class="uc">Error</span> <span class="pn">(</span><span onmouseout="hideTip(event, '99', 372)" onmouseover="showTip(event, '99', 372)" class="fn">newVersion</span><span class="pn">,</span> <span onmouseout="hideTip(event, '100', 373)" onmouseover="showTip(event, '100', 373)" class="fn">newEvents</span><span class="pn">)</span> <span class="k">-&gt;</span>
                    <span class="c">// it failed, but we have events that we missed</span>
                    <span class="c">// compute current state</span>
                    <span class="k">let</span> <span onmouseout="hideTip(event, '65', 374)" onmouseover="showTip(event, '65', 374)" class="fn">newState</span> <span class="o">=</span> <span onmouseout="hideTip(event, '44', 375)" onmouseover="showTip(event, '44', 375)" class="m">List</span><span class="pn">.</span><span onmouseout="hideTip(event, '45', 376)" onmouseover="showTip(event, '45', 376)" class="id">fold</span> <span onmouseout="hideTip(event, '54', 377)" onmouseover="showTip(event, '54', 377)" class="fn">decider</span><span class="pn">.</span><span onmouseout="hideTip(event, '50', 378)" onmouseover="showTip(event, '50', 378)" class="id">evolve</span> <span onmouseout="hideTip(event, '61', 379)" onmouseover="showTip(event, '61', 379)" class="fn">state</span> <span onmouseout="hideTip(event, '100', 380)" onmouseover="showTip(event, '100', 380)" class="fn">newEvents</span>
                    <span class="c">// and try again</span>
                    <span onmouseout="hideTip(event, '95', 381)" onmouseover="showTip(event, '95', 381)" class="fn">handle</span> <span onmouseout="hideTip(event, '99', 382)" onmouseover="showTip(event, '99', 382)" class="fn">newVersion</span> <span onmouseout="hideTip(event, '65', 383)" onmouseover="showTip(event, '65', 383)" class="fn">newState</span> 
            <span class="c">// load past events </span>
            <span class="k">let</span> <span onmouseout="hideTip(event, '87', 384)" onmouseover="showTip(event, '87', 384)" class="fn">version</span><span class="pn">,</span> <span onmouseout="hideTip(event, '101', 385)" onmouseover="showTip(event, '101', 385)" class="fn">pastEvents</span> <span class="o">=</span> <span onmouseout="hideTip(event, '96', 386)" onmouseover="showTip(event, '96', 386)" class="m">EventStoreWithVersion</span><span class="pn">.</span><span onmouseout="hideTip(event, '91', 387)" onmouseover="showTip(event, '91', 387)" class="id">loadEvents</span><span class="pn">(</span><span onmouseout="hideTip(event, '86', 388)" onmouseover="showTip(event, '86', 388)" class="fn">stream</span><span class="pn">)</span>
            <span class="c">// compute current state</span>
            <span class="k">let</span> <span onmouseout="hideTip(event, '61', 389)" onmouseover="showTip(event, '61', 389)" class="fn">state</span> <span class="o">=</span> <span onmouseout="hideTip(event, '44', 390)" onmouseover="showTip(event, '44', 390)" class="m">List</span><span class="pn">.</span><span onmouseout="hideTip(event, '45', 391)" onmouseover="showTip(event, '45', 391)" class="id">fold</span> <span onmouseout="hideTip(event, '54', 392)" onmouseover="showTip(event, '54', 392)" class="fn">decider</span><span class="pn">.</span><span onmouseout="hideTip(event, '50', 393)" onmouseover="showTip(event, '50', 393)" class="id">evolve</span> <span onmouseout="hideTip(event, '54', 394)" onmouseover="showTip(event, '54', 394)" class="fn">decider</span><span class="pn">.</span><span onmouseout="hideTip(event, '51', 395)" onmouseover="showTip(event, '51', 395)" class="id">initialState</span> <span onmouseout="hideTip(event, '101', 396)" onmouseover="showTip(event, '101', 396)" class="fn">pastEvents</span>
            <span onmouseout="hideTip(event, '95', 397)" onmouseover="showTip(event, '95', 397)" class="fn">handle</span> <span onmouseout="hideTip(event, '87', 398)" onmouseover="showTip(event, '87', 398)" class="fn">version</span> <span onmouseout="hideTip(event, '61', 399)" onmouseover="showTip(event, '61', 399)" class="fn">state</span>
</code></pre>
          <p>This can obviously be extended to keep state in memory:</p>
          <pre
            class="fssnip highlighted"
          ><code lang="fsharp"><span class="k">module</span> <span class="m">WithEventStoreInMemory</span> <span class="o">=</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, '102', 400)" onmouseover="showTip(event, '102', 400)" class="fn">start</span> <span onmouseout="hideTip(event, '86', 401)" onmouseover="showTip(event, '86', 401)" class="fn">stream</span> <span class="pn">(</span><span onmouseout="hideTip(event, '54', 402)" onmouseover="showTip(event, '54', 402)" class="fn">decider</span><span class="pn">:</span> <span onmouseout="hideTip(event, '48', 403)" onmouseover="showTip(event, '48', 403)" class="rt">Decider</span><span class="pn">&lt;</span><span class="ta">'</span><span class="id">c</span><span class="pn">,</span><span class="ta">'</span><span class="id">e</span><span class="pn">,</span><span class="ta">'</span><span class="id">s</span><span class="pn">&gt;</span><span class="pn">)</span> <span class="o">=</span>
        <span class="k">let</span> <span class="k">mutable</span> <span onmouseout="hideTip(event, '103', 404)" onmouseover="showTip(event, '103', 404)" class="mv">versionAndState</span> <span class="o">=</span>
            <span class="k">let</span> <span onmouseout="hideTip(event, '87', 405)" onmouseover="showTip(event, '87', 405)" class="fn">version</span><span class="pn">,</span> <span onmouseout="hideTip(event, '101', 406)" onmouseover="showTip(event, '101', 406)" class="fn">pastEvents</span> <span class="o">=</span> <span onmouseout="hideTip(event, '96', 407)" onmouseover="showTip(event, '96', 407)" class="m">EventStoreWithVersion</span><span class="pn">.</span><span onmouseout="hideTip(event, '91', 408)" onmouseover="showTip(event, '91', 408)" class="id">loadEvents</span><span class="pn">(</span><span onmouseout="hideTip(event, '86', 409)" onmouseover="showTip(event, '86', 409)" class="fn">stream</span><span class="pn">)</span>
            <span class="c">// compute current state</span>
            <span class="k">let</span> <span onmouseout="hideTip(event, '61', 410)" onmouseover="showTip(event, '61', 410)" class="fn">state</span> <span class="o">=</span> <span onmouseout="hideTip(event, '44', 411)" onmouseover="showTip(event, '44', 411)" class="m">List</span><span class="pn">.</span><span onmouseout="hideTip(event, '45', 412)" onmouseover="showTip(event, '45', 412)" class="id">fold</span> <span onmouseout="hideTip(event, '54', 413)" onmouseover="showTip(event, '54', 413)" class="fn">decider</span><span class="pn">.</span><span onmouseout="hideTip(event, '50', 414)" onmouseover="showTip(event, '50', 414)" class="id">evolve</span> <span onmouseout="hideTip(event, '54', 415)" onmouseover="showTip(event, '54', 415)" class="fn">decider</span><span class="pn">.</span><span onmouseout="hideTip(event, '51', 416)" onmouseover="showTip(event, '51', 416)" class="id">initialState</span> <span onmouseout="hideTip(event, '101', 417)" onmouseover="showTip(event, '101', 417)" class="fn">pastEvents</span>
            <span onmouseout="hideTip(event, '87', 418)" onmouseover="showTip(event, '87', 418)" class="fn">version</span><span class="pn">,</span> <span onmouseout="hideTip(event, '61', 419)" onmouseover="showTip(event, '61', 419)" class="fn">state</span>

        <span class="k">fun</span> <span class="pn">(</span><span onmouseout="hideTip(event, '56', 420)" onmouseover="showTip(event, '56', 420)" class="fn">command</span><span class="pn">:</span> <span class="ta">'</span><span class="id">c</span><span class="pn">)</span> <span class="k">-&gt;</span>
            <span class="k">let</span> <span class="k">rec</span> <span onmouseout="hideTip(event, '104', 421)" onmouseover="showTip(event, '104', 421)" class="fn">handle</span> <span class="pn">(</span><span onmouseout="hideTip(event, '87', 422)" onmouseover="showTip(event, '87', 422)" class="fn">version</span><span class="pn">,</span> <span onmouseout="hideTip(event, '61', 423)" onmouseover="showTip(event, '61', 423)" class="fn">state</span><span class="pn">)</span> <span class="o">=</span>
                <span class="c">// get events from decision</span>
                <span class="k">let</span> <span onmouseout="hideTip(event, '57', 424)" onmouseover="showTip(event, '57', 424)" class="fn">events</span> <span class="o">=</span> <span onmouseout="hideTip(event, '54', 425)" onmouseover="showTip(event, '54', 425)" class="fn">decider</span><span class="pn">.</span><span onmouseout="hideTip(event, '49', 426)" onmouseover="showTip(event, '49', 426)" class="id">decide</span> <span onmouseout="hideTip(event, '56', 427)" onmouseover="showTip(event, '56', 427)" class="fn">command</span> <span onmouseout="hideTip(event, '61', 428)" onmouseover="showTip(event, '61', 428)" class="fn">state</span>
                <span class="k">match</span> <span onmouseout="hideTip(event, '96', 429)" onmouseover="showTip(event, '96', 429)" class="m">EventStoreWithVersion</span><span class="pn">.</span><span onmouseout="hideTip(event, '92', 430)" onmouseover="showTip(event, '92', 430)" class="id">tryAppendEvents</span><span class="pn">(</span><span onmouseout="hideTip(event, '86', 431)" onmouseover="showTip(event, '86', 431)" class="fn">stream</span><span class="pn">,</span> <span onmouseout="hideTip(event, '87', 432)" onmouseover="showTip(event, '87', 432)" class="fn">version</span><span class="pn">,</span> <span onmouseout="hideTip(event, '57', 433)" onmouseover="showTip(event, '57', 433)" class="fn">events</span><span class="pn">)</span> <span class="k">with</span>
                <span class="pn">|</span> <span onmouseout="hideTip(event, '97', 434)" onmouseover="showTip(event, '97', 434)" class="uc">Ok</span> <span onmouseout="hideTip(event, '99', 435)" onmouseover="showTip(event, '99', 435)" class="fn">newVersion</span> <span class="k">-&gt;</span>
                    <span class="c">// save succeeded, we can return events</span>
                    <span class="k">let</span> <span onmouseout="hideTip(event, '65', 436)" onmouseover="showTip(event, '65', 436)" class="fn">newState</span> <span class="o">=</span> <span onmouseout="hideTip(event, '44', 437)" onmouseover="showTip(event, '44', 437)" class="m">List</span><span class="pn">.</span><span onmouseout="hideTip(event, '45', 438)" onmouseover="showTip(event, '45', 438)" class="id">fold</span> <span onmouseout="hideTip(event, '54', 439)" onmouseover="showTip(event, '54', 439)" class="fn">decider</span><span class="pn">.</span><span onmouseout="hideTip(event, '50', 440)" onmouseover="showTip(event, '50', 440)" class="id">evolve</span> <span onmouseout="hideTip(event, '61', 441)" onmouseover="showTip(event, '61', 441)" class="fn">state</span> <span onmouseout="hideTip(event, '57', 442)" onmouseover="showTip(event, '57', 442)" class="fn">events</span>
                    <span onmouseout="hideTip(event, '103', 443)" onmouseover="showTip(event, '103', 443)" class="mv">versionAndState</span> <span class="k">&lt;-</span><span class="pn">(</span><span onmouseout="hideTip(event, '99', 444)" onmouseover="showTip(event, '99', 444)" class="fn">newVersion</span><span class="pn">,</span> <span onmouseout="hideTip(event, '65', 445)" onmouseover="showTip(event, '65', 445)" class="fn">newState</span><span class="pn">)</span>
                    <span onmouseout="hideTip(event, '57', 446)" onmouseover="showTip(event, '57', 446)" class="fn">events</span>
                <span class="pn">|</span> <span onmouseout="hideTip(event, '98', 447)" onmouseover="showTip(event, '98', 447)" class="uc">Error</span> <span class="pn">(</span><span onmouseout="hideTip(event, '99', 448)" onmouseover="showTip(event, '99', 448)" class="fn">newVersion</span><span class="pn">,</span> <span onmouseout="hideTip(event, '100', 449)" onmouseover="showTip(event, '100', 449)" class="fn">newEvents</span><span class="pn">)</span> <span class="k">-&gt;</span>
                    <span class="c">// it failed, but we have events that we missed</span>
                    <span class="c">// compute current state</span>
                    <span class="k">let</span> <span onmouseout="hideTip(event, '65', 450)" onmouseover="showTip(event, '65', 450)" class="fn">newState</span> <span class="o">=</span> <span onmouseout="hideTip(event, '44', 451)" onmouseover="showTip(event, '44', 451)" class="m">List</span><span class="pn">.</span><span onmouseout="hideTip(event, '45', 452)" onmouseover="showTip(event, '45', 452)" class="id">fold</span> <span onmouseout="hideTip(event, '54', 453)" onmouseover="showTip(event, '54', 453)" class="fn">decider</span><span class="pn">.</span><span onmouseout="hideTip(event, '50', 454)" onmouseover="showTip(event, '50', 454)" class="id">evolve</span> <span onmouseout="hideTip(event, '61', 455)" onmouseover="showTip(event, '61', 455)" class="fn">state</span> <span onmouseout="hideTip(event, '100', 456)" onmouseover="showTip(event, '100', 456)" class="fn">newEvents</span>
                    <span class="c">// and try again</span>
                    <span onmouseout="hideTip(event, '104', 457)" onmouseover="showTip(event, '104', 457)" class="fn">handle</span> <span class="pn">(</span><span onmouseout="hideTip(event, '99', 458)" onmouseover="showTip(event, '99', 458)" class="fn">newVersion</span><span class="pn">,</span> <span onmouseout="hideTip(event, '65', 459)" onmouseover="showTip(event, '65', 459)" class="fn">newState</span><span class="pn">)</span>

            <span onmouseout="hideTip(event, '104', 460)" onmouseover="showTip(event, '104', 460)" class="fn">handle</span> <span onmouseout="hideTip(event, '103', 461)" onmouseover="showTip(event, '103', 461)" class="mv">versionAndState</span>
</code></pre>
          <h2>
            <a name="Snapshots" class="anchor" href="#Snapshots">Snapshots</a>
          </h2>
          <p>
            Once you have many events, it can become long to reload everything.
            It is then possible to save the state periodically along with the
            version of the stream that produced this state. The snapshots can be
            saved in a key value store:
          </p>
          <pre
            class="fssnip highlighted"
          ><code lang="fsharp"><span class="k">module</span> <span class="m">WithSnapshots</span> <span class="o">=</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, '74', 478)" onmouseover="showTip(event, '74', 478)" class="fn">start</span> <span class="pn">(</span><span onmouseout="hideTip(event, '54', 479)" onmouseover="showTip(event, '54', 479)" class="fn">decider</span><span class="pn">:</span> <span onmouseout="hideTip(event, '48', 480)" onmouseover="showTip(event, '48', 480)" class="rt">Decider</span><span class="pn">&lt;</span><span class="ta">'</span><span class="id">c</span><span class="pn">,</span><span class="ta">'</span><span class="id">e</span><span class="pn">,</span><span class="ta">'</span><span class="id">s</span><span class="pn">&gt;</span><span class="pn">)</span> <span class="o">=</span>
        <span class="c">// load state using snapshot if any</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, '109', 481)" onmouseover="showTip(event, '109', 481)" class="fn">loadState</span> <span onmouseout="hideTip(event, '110', 482)" onmouseover="showTip(event, '110', 482)" class="fn">stream</span> <span class="o">=</span>
            <span class="c">// load snapshot</span>
            <span class="k">let</span> <span onmouseout="hideTip(event, '111', 483)" onmouseover="showTip(event, '111', 483)" class="fn">snapVersion</span><span class="pn">,</span> <span onmouseout="hideTip(event, '112', 484)" onmouseover="showTip(event, '112', 484)" class="fn">snapState</span> <span class="o">=</span>
                <span onmouseout="hideTip(event, '113', 485)" onmouseover="showTip(event, '113', 485)" class="m">Snapshots</span><span class="pn">.</span><span onmouseout="hideTip(event, '105', 486)" onmouseover="showTip(event, '105', 486)" class="id">tryLoadSnapshot</span><span class="pn">(</span><span onmouseout="hideTip(event, '110', 487)" onmouseover="showTip(event, '110', 487)" class="fn">stream</span><span class="pn">)</span>
                    <span class="c">// fallback to version 0 and initialState if not found</span>
                <span class="o">|&gt;</span> <span onmouseout="hideTip(event, '114', 488)" onmouseover="showTip(event, '114', 488)" class="m">Option</span><span class="pn">.</span><span onmouseout="hideTip(event, '115', 489)" onmouseover="showTip(event, '115', 489)" class="id">defaultValue</span> <span class="pn">(</span><span class="n">0</span><span class="pn">,</span> <span onmouseout="hideTip(event, '54', 490)" onmouseover="showTip(event, '54', 490)" class="fn">decider</span><span class="pn">.</span><span onmouseout="hideTip(event, '51', 491)" onmouseover="showTip(event, '51', 491)" class="id">initialState</span><span class="pn">)</span>

            <span class="c">// load version and events after snapshot</span>
            <span class="k">let</span> <span onmouseout="hideTip(event, '87', 492)" onmouseover="showTip(event, '87', 492)" class="fn">version</span><span class="pn">,</span> <span onmouseout="hideTip(event, '57', 493)" onmouseover="showTip(event, '57', 493)" class="fn">events</span> <span class="o">=</span> 
                <span onmouseout="hideTip(event, '96', 494)" onmouseover="showTip(event, '96', 494)" class="m">EventStoreWithVersion</span><span class="pn">.</span><span onmouseout="hideTip(event, '91', 495)" onmouseover="showTip(event, '91', 495)" class="id">loadEvents</span><span class="pn">(</span><span onmouseout="hideTip(event, '110', 496)" onmouseover="showTip(event, '110', 496)" class="fn">stream</span><span class="pn">,</span> <span onmouseout="hideTip(event, '111', 497)" onmouseover="showTip(event, '111', 497)" class="fn">snapVersion</span><span class="pn">)</span>
            <span class="c">// fold events after snapshot</span>
            <span class="k">let</span> <span onmouseout="hideTip(event, '61', 498)" onmouseover="showTip(event, '61', 498)" class="fn">state</span> <span class="o">=</span> <span onmouseout="hideTip(event, '44', 499)" onmouseover="showTip(event, '44', 499)" class="m">List</span><span class="pn">.</span><span onmouseout="hideTip(event, '45', 500)" onmouseover="showTip(event, '45', 500)" class="id">fold</span> <span onmouseout="hideTip(event, '54', 501)" onmouseover="showTip(event, '54', 501)" class="fn">decider</span><span class="pn">.</span><span onmouseout="hideTip(event, '50', 502)" onmouseover="showTip(event, '50', 502)" class="id">evolve</span> <span onmouseout="hideTip(event, '112', 503)" onmouseover="showTip(event, '112', 503)" class="fn">snapState</span> <span onmouseout="hideTip(event, '57', 504)" onmouseover="showTip(event, '57', 504)" class="fn">events</span>
            <span onmouseout="hideTip(event, '87', 505)" onmouseover="showTip(event, '87', 505)" class="fn">version</span><span class="pn">,</span> <span onmouseout="hideTip(event, '61', 506)" onmouseover="showTip(event, '61', 506)" class="fn">state</span>

        <span class="k">fun</span> <span onmouseout="hideTip(event, '86', 507)" onmouseover="showTip(event, '86', 507)" class="fn">stream</span> <span class="pn">(</span><span onmouseout="hideTip(event, '56', 508)" onmouseover="showTip(event, '56', 508)" class="fn">command</span><span class="pn">:</span> <span class="ta">'</span><span class="id">c</span><span class="pn">)</span> <span class="k">-&gt;</span>
            <span class="k">let</span> <span class="k">rec</span> <span onmouseout="hideTip(event, '104', 509)" onmouseover="showTip(event, '104', 509)" class="fn">handle</span> <span class="pn">(</span><span onmouseout="hideTip(event, '87', 510)" onmouseover="showTip(event, '87', 510)" class="fn">version</span><span class="pn">,</span> <span onmouseout="hideTip(event, '61', 511)" onmouseover="showTip(event, '61', 511)" class="fn">state</span><span class="pn">)</span> <span class="o">=</span>
                <span class="c">// get events from the decision</span>
                <span class="k">let</span> <span onmouseout="hideTip(event, '57', 512)" onmouseover="showTip(event, '57', 512)" class="fn">events</span> <span class="o">=</span> <span onmouseout="hideTip(event, '54', 513)" onmouseover="showTip(event, '54', 513)" class="fn">decider</span><span class="pn">.</span><span onmouseout="hideTip(event, '49', 514)" onmouseover="showTip(event, '49', 514)" class="id">decide</span> <span onmouseout="hideTip(event, '56', 515)" onmouseover="showTip(event, '56', 515)" class="fn">command</span> <span onmouseout="hideTip(event, '61', 516)" onmouseover="showTip(event, '61', 516)" class="fn">state</span>
                <span class="c">// append events to stream</span>
                <span class="k">match</span> <span onmouseout="hideTip(event, '96', 517)" onmouseover="showTip(event, '96', 517)" class="m">EventStoreWithVersion</span><span class="pn">.</span><span onmouseout="hideTip(event, '92', 518)" onmouseover="showTip(event, '92', 518)" class="id">tryAppendEvents</span><span class="pn">(</span><span onmouseout="hideTip(event, '86', 519)" onmouseover="showTip(event, '86', 519)" class="fn">stream</span><span class="pn">,</span> <span onmouseout="hideTip(event, '87', 520)" onmouseover="showTip(event, '87', 520)" class="fn">version</span><span class="pn">,</span> <span onmouseout="hideTip(event, '57', 521)" onmouseover="showTip(event, '57', 521)" class="fn">events</span><span class="pn">)</span> <span class="k">with</span>
                <span class="pn">|</span> <span onmouseout="hideTip(event, '97', 522)" onmouseover="showTip(event, '97', 522)" class="uc">Ok</span> <span onmouseout="hideTip(event, '99', 523)" onmouseover="showTip(event, '99', 523)" class="fn">newVersion</span> <span class="k">-&gt;</span>
                    <span class="k">if</span> <span onmouseout="hideTip(event, '107', 524)" onmouseover="showTip(event, '107', 524)" class="fn">isTimeToSnapshot</span> <span onmouseout="hideTip(event, '87', 525)" onmouseover="showTip(event, '87', 525)" class="fn">version</span> <span class="k">then</span>
                        <span class="c">// it is time to save snapshot</span>
                        <span class="c">// compute state</span>
                        <span class="k">let</span> <span onmouseout="hideTip(event, '65', 526)" onmouseover="showTip(event, '65', 526)" class="fn">newState</span> <span class="o">=</span> <span onmouseout="hideTip(event, '44', 527)" onmouseover="showTip(event, '44', 527)" class="m">List</span><span class="pn">.</span><span onmouseout="hideTip(event, '45', 528)" onmouseover="showTip(event, '45', 528)" class="id">fold</span> <span onmouseout="hideTip(event, '54', 529)" onmouseover="showTip(event, '54', 529)" class="fn">decider</span><span class="pn">.</span><span onmouseout="hideTip(event, '50', 530)" onmouseover="showTip(event, '50', 530)" class="id">evolve</span> <span onmouseout="hideTip(event, '61', 531)" onmouseover="showTip(event, '61', 531)" class="fn">state</span> <span onmouseout="hideTip(event, '57', 532)" onmouseover="showTip(event, '57', 532)" class="fn">events</span>
                        <span class="c">// save it</span>
                        <span onmouseout="hideTip(event, '113', 533)" onmouseover="showTip(event, '113', 533)" class="m">Snapshots</span><span class="pn">.</span><span onmouseout="hideTip(event, '106', 534)" onmouseover="showTip(event, '106', 534)" class="id">saveSnapshot</span><span class="pn">(</span><span onmouseout="hideTip(event, '86', 535)" onmouseover="showTip(event, '86', 535)" class="fn">stream</span><span class="pn">,</span> <span onmouseout="hideTip(event, '99', 536)" onmouseover="showTip(event, '99', 536)" class="fn">newVersion</span><span class="pn">,</span> <span onmouseout="hideTip(event, '65', 537)" onmouseover="showTip(event, '65', 537)" class="fn">newState</span><span class="pn">)</span>
                    <span onmouseout="hideTip(event, '57', 538)" onmouseover="showTip(event, '57', 538)" class="fn">events</span>
                <span class="pn">|</span> <span onmouseout="hideTip(event, '98', 539)" onmouseover="showTip(event, '98', 539)" class="uc">Error</span><span class="pn">(</span><span onmouseout="hideTip(event, '99', 540)" onmouseover="showTip(event, '99', 540)" class="fn">newVersion</span><span class="pn">,</span> <span onmouseout="hideTip(event, '100', 541)" onmouseover="showTip(event, '100', 541)" class="fn">newEvents</span><span class="pn">)</span> <span class="k">-&gt;</span>
                    <span class="c">// there was a concurrent write</span>
                    <span class="c">// catch-up missing events and retry</span>
                    <span class="k">let</span> <span onmouseout="hideTip(event, '65', 542)" onmouseover="showTip(event, '65', 542)" class="fn">newState</span> <span class="o">=</span> <span onmouseout="hideTip(event, '44', 543)" onmouseover="showTip(event, '44', 543)" class="m">List</span><span class="pn">.</span><span onmouseout="hideTip(event, '45', 544)" onmouseover="showTip(event, '45', 544)" class="id">fold</span> <span onmouseout="hideTip(event, '54', 545)" onmouseover="showTip(event, '54', 545)" class="fn">decider</span><span class="pn">.</span><span onmouseout="hideTip(event, '50', 546)" onmouseover="showTip(event, '50', 546)" class="id">evolve</span> <span onmouseout="hideTip(event, '61', 547)" onmouseover="showTip(event, '61', 547)" class="fn">state</span> <span onmouseout="hideTip(event, '100', 548)" onmouseover="showTip(event, '100', 548)" class="fn">newEvents</span>
                    <span onmouseout="hideTip(event, '104', 549)" onmouseover="showTip(event, '104', 549)" class="fn">handle</span> <span class="pn">(</span><span onmouseout="hideTip(event, '99', 550)" onmouseover="showTip(event, '99', 550)" class="fn">newVersion</span><span class="pn">,</span> <span onmouseout="hideTip(event, '65', 551)" onmouseover="showTip(event, '65', 551)" class="fn">newState</span><span class="pn">)</span>


            <span class="c">// load all past events to compute current state</span>
            <span class="c">// using snapshot if any</span>
            <span class="k">let</span> <span onmouseout="hideTip(event, '87', 552)" onmouseover="showTip(event, '87', 552)" class="fn">version</span><span class="pn">,</span> <span onmouseout="hideTip(event, '61', 553)" onmouseover="showTip(event, '61', 553)" class="fn">state</span> <span class="o">=</span> <span onmouseout="hideTip(event, '109', 554)" onmouseover="showTip(event, '109', 554)" class="fn">loadState</span> <span onmouseout="hideTip(event, '86', 555)" onmouseover="showTip(event, '86', 555)" class="fn">stream</span>
            <span onmouseout="hideTip(event, '104', 556)" onmouseover="showTip(event, '104', 556)" class="fn">handle</span> <span class="pn">(</span><span onmouseout="hideTip(event, '87', 557)" onmouseover="showTip(event, '87', 557)" class="fn">version</span><span class="pn">,</span> <span onmouseout="hideTip(event, '61', 558)" onmouseover="showTip(event, '61', 558)" class="fn">state</span><span class="pn">)</span>
</code></pre>
          <p>
            Here again we have the problem of snapshot invalidation. The easiest
            way to deal with it is to store all snapshots for a same version of
            the code in a same collection, container or database, and change it
            when snapshots are not valid anymore. This happens when the
            structure of the state changes after a refactoring. The saved
            snapshots won't have the expected shape which could cause some
            errors.
          </p>
          <p>
            You can just change the collection/container/database name when this
            happen. The collection will be empty on start and snapshots will be
            recomputed. You can also recompute snapshots in advance before
            deploying a new version.
          </p>
          <p>
            Once deployed and checked that old version is not needed anymore,
            you can just delete the old collection.
          </p>
          <p>
            Ideally you would compute the collection name as a hash of the
            evolve function, this way, snapshots will be automatically discarded
            when the evolve function changes (which always happens when the
            state structure changes)
          </p>
          <pre
            class="fssnip highlighted"
          ><code lang="fsharp"><span class="k">module</span> <span onmouseout="hideTip(event, '120', 575)" onmouseover="showTip(event, '120', 575)" class="m">WithSnapshotsInContainers</span> <span class="o">=</span>
    <span class="k">let</span> <span onmouseout="hideTip(event, '74', 576)" onmouseover="showTip(event, '74', 576)" class="fn">start</span> <span class="pn">(</span><span onmouseout="hideTip(event, '54', 577)" onmouseover="showTip(event, '54', 577)" class="fn">decider</span><span class="pn">:</span> <span onmouseout="hideTip(event, '48', 578)" onmouseover="showTip(event, '48', 578)" class="rt">Decider</span><span class="pn">&lt;</span><span class="ta">'</span><span class="id">c</span><span class="pn">,</span><span class="ta">'</span><span class="id">e</span><span class="pn">,</span><span class="ta">'</span><span class="id">s</span><span class="pn">&gt;</span><span class="pn">)</span> <span class="o">=</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, '121', 579)" onmouseover="showTip(event, '121', 579)" class="fn">container</span> <span class="o">=</span> <span onmouseout="hideTip(event, '119', 580)" onmouseover="showTip(event, '119', 580)" class="fn">getContainerFromDecideHash</span><span class="pn">(</span><span onmouseout="hideTip(event, '54', 581)" onmouseover="showTip(event, '54', 581)" class="fn">decider</span><span class="pn">)</span>
        <span class="c">// load state using snapshot if any</span>
        <span class="k">let</span> <span onmouseout="hideTip(event, '109', 582)" onmouseover="showTip(event, '109', 582)" class="fn">loadState</span> <span onmouseout="hideTip(event, '110', 583)" onmouseover="showTip(event, '110', 583)" class="fn">stream</span> <span class="o">=</span>
            <span class="c">// load snapshot.. it will not be found id container has</span>
            <span class="c">// changed since last run</span>
            <span class="k">let</span> <span onmouseout="hideTip(event, '111', 584)" onmouseover="showTip(event, '111', 584)" class="fn">snapVersion</span><span class="pn">,</span> <span onmouseout="hideTip(event, '112', 585)" onmouseover="showTip(event, '112', 585)" class="fn">snapState</span> <span class="o">=</span>
                <span onmouseout="hideTip(event, '122', 586)" onmouseover="showTip(event, '122', 586)" class="m">SnapshotsWithContainer</span><span class="pn">.</span><span onmouseout="hideTip(event, '116', 587)" onmouseover="showTip(event, '116', 587)" class="id">tryLoadSnapshot</span><span class="pn">(</span><span onmouseout="hideTip(event, '110', 588)" onmouseover="showTip(event, '110', 588)" class="fn">stream</span><span class="pn">,</span> <span onmouseout="hideTip(event, '121', 589)" onmouseover="showTip(event, '121', 589)" class="fn">container</span><span class="pn">)</span>
                    <span class="c">// fallback to version 0 and initialState if not found</span>
                <span class="o">|&gt;</span> <span onmouseout="hideTip(event, '114', 590)" onmouseover="showTip(event, '114', 590)" class="m">Option</span><span class="pn">.</span><span onmouseout="hideTip(event, '115', 591)" onmouseover="showTip(event, '115', 591)" class="id">defaultValue</span> <span class="pn">(</span><span class="n">0</span><span class="pn">,</span> <span onmouseout="hideTip(event, '54', 592)" onmouseover="showTip(event, '54', 592)" class="fn">decider</span><span class="pn">.</span><span onmouseout="hideTip(event, '51', 593)" onmouseover="showTip(event, '51', 593)" class="id">initialState</span><span class="pn">)</span>

            <span class="c">// load version and events after snapshot</span>
            <span class="k">let</span> <span onmouseout="hideTip(event, '87', 594)" onmouseover="showTip(event, '87', 594)" class="fn">version</span><span class="pn">,</span> <span onmouseout="hideTip(event, '57', 595)" onmouseover="showTip(event, '57', 595)" class="fn">events</span> <span class="o">=</span> 
                <span onmouseout="hideTip(event, '96', 596)" onmouseover="showTip(event, '96', 596)" class="m">EventStoreWithVersion</span><span class="pn">.</span><span onmouseout="hideTip(event, '91', 597)" onmouseover="showTip(event, '91', 597)" class="id">loadEvents</span><span class="pn">(</span><span onmouseout="hideTip(event, '110', 598)" onmouseover="showTip(event, '110', 598)" class="fn">stream</span><span class="pn">,</span> <span onmouseout="hideTip(event, '111', 599)" onmouseover="showTip(event, '111', 599)" class="fn">snapVersion</span><span class="pn">)</span>
            <span class="c">// fold events after snapshot</span>
            <span class="k">let</span> <span onmouseout="hideTip(event, '61', 600)" onmouseover="showTip(event, '61', 600)" class="fn">state</span> <span class="o">=</span> <span onmouseout="hideTip(event, '44', 601)" onmouseover="showTip(event, '44', 601)" class="m">List</span><span class="pn">.</span><span onmouseout="hideTip(event, '45', 602)" onmouseover="showTip(event, '45', 602)" class="id">fold</span> <span onmouseout="hideTip(event, '54', 603)" onmouseover="showTip(event, '54', 603)" class="fn">decider</span><span class="pn">.</span><span onmouseout="hideTip(event, '50', 604)" onmouseover="showTip(event, '50', 604)" class="id">evolve</span> <span onmouseout="hideTip(event, '112', 605)" onmouseover="showTip(event, '112', 605)" class="fn">snapState</span> <span onmouseout="hideTip(event, '57', 606)" onmouseover="showTip(event, '57', 606)" class="fn">events</span>
            <span onmouseout="hideTip(event, '87', 607)" onmouseover="showTip(event, '87', 607)" class="fn">version</span><span class="pn">,</span> <span onmouseout="hideTip(event, '61', 608)" onmouseover="showTip(event, '61', 608)" class="fn">state</span>

        <span class="k">fun</span> <span onmouseout="hideTip(event, '86', 609)" onmouseover="showTip(event, '86', 609)" class="fn">stream</span> <span class="pn">(</span><span onmouseout="hideTip(event, '56', 610)" onmouseover="showTip(event, '56', 610)" class="fn">command</span><span class="pn">:</span> <span class="ta">'</span><span class="id">c</span><span class="pn">)</span> <span class="k">-&gt;</span>
            <span class="k">let</span> <span class="k">rec</span> <span onmouseout="hideTip(event, '104', 611)" onmouseover="showTip(event, '104', 611)" class="fn">handle</span> <span class="pn">(</span><span onmouseout="hideTip(event, '87', 612)" onmouseover="showTip(event, '87', 612)" class="fn">version</span><span class="pn">,</span> <span onmouseout="hideTip(event, '61', 613)" onmouseover="showTip(event, '61', 613)" class="fn">state</span><span class="pn">)</span> <span class="o">=</span>
                <span class="c">// get events from the decision</span>
                <span class="k">let</span> <span onmouseout="hideTip(event, '57', 614)" onmouseover="showTip(event, '57', 614)" class="fn">events</span> <span class="o">=</span> <span onmouseout="hideTip(event, '54', 615)" onmouseover="showTip(event, '54', 615)" class="fn">decider</span><span class="pn">.</span><span onmouseout="hideTip(event, '49', 616)" onmouseover="showTip(event, '49', 616)" class="id">decide</span> <span onmouseout="hideTip(event, '56', 617)" onmouseover="showTip(event, '56', 617)" class="fn">command</span> <span onmouseout="hideTip(event, '61', 618)" onmouseover="showTip(event, '61', 618)" class="fn">state</span>
                <span class="c">// append events to stream</span>
                <span class="k">match</span> <span onmouseout="hideTip(event, '96', 619)" onmouseover="showTip(event, '96', 619)" class="m">EventStoreWithVersion</span><span class="pn">.</span><span onmouseout="hideTip(event, '92', 620)" onmouseover="showTip(event, '92', 620)" class="id">tryAppendEvents</span><span class="pn">(</span><span onmouseout="hideTip(event, '86', 621)" onmouseover="showTip(event, '86', 621)" class="fn">stream</span><span class="pn">,</span> <span onmouseout="hideTip(event, '87', 622)" onmouseover="showTip(event, '87', 622)" class="fn">version</span><span class="pn">,</span> <span onmouseout="hideTip(event, '57', 623)" onmouseover="showTip(event, '57', 623)" class="fn">events</span><span class="pn">)</span> <span class="k">with</span>
                <span class="pn">|</span> <span onmouseout="hideTip(event, '97', 624)" onmouseover="showTip(event, '97', 624)" class="uc">Ok</span> <span onmouseout="hideTip(event, '99', 625)" onmouseover="showTip(event, '99', 625)" class="fn">newVersion</span> <span class="k">-&gt;</span>
                    <span class="k">if</span> <span onmouseout="hideTip(event, '107', 626)" onmouseover="showTip(event, '107', 626)" class="fn">isTimeToSnapshot</span> <span onmouseout="hideTip(event, '87', 627)" onmouseover="showTip(event, '87', 627)" class="fn">version</span> <span class="k">then</span>
                        <span class="c">// it is time to save snapshot</span>
                        <span class="c">// compute state</span>
                        <span class="k">let</span> <span onmouseout="hideTip(event, '65', 628)" onmouseover="showTip(event, '65', 628)" class="fn">newState</span> <span class="o">=</span> <span onmouseout="hideTip(event, '44', 629)" onmouseover="showTip(event, '44', 629)" class="m">List</span><span class="pn">.</span><span onmouseout="hideTip(event, '45', 630)" onmouseover="showTip(event, '45', 630)" class="id">fold</span> <span onmouseout="hideTip(event, '54', 631)" onmouseover="showTip(event, '54', 631)" class="fn">decider</span><span class="pn">.</span><span onmouseout="hideTip(event, '50', 632)" onmouseover="showTip(event, '50', 632)" class="id">evolve</span> <span onmouseout="hideTip(event, '61', 633)" onmouseover="showTip(event, '61', 633)" class="fn">state</span> <span onmouseout="hideTip(event, '57', 634)" onmouseover="showTip(event, '57', 634)" class="fn">events</span>
                        <span class="c">// save it</span>
                        <span onmouseout="hideTip(event, '122', 635)" onmouseover="showTip(event, '122', 635)" class="m">SnapshotsWithContainer</span><span class="pn">.</span><span onmouseout="hideTip(event, '118', 636)" onmouseover="showTip(event, '118', 636)" class="id">saveSnapshot</span><span class="pn">(</span><span onmouseout="hideTip(event, '86', 637)" onmouseover="showTip(event, '86', 637)" class="fn">stream</span><span class="pn">,</span> <span onmouseout="hideTip(event, '121', 638)" onmouseover="showTip(event, '121', 638)" class="fn">container</span><span class="pn">,</span> <span onmouseout="hideTip(event, '99', 639)" onmouseover="showTip(event, '99', 639)" class="fn">newVersion</span><span class="pn">,</span> <span onmouseout="hideTip(event, '65', 640)" onmouseover="showTip(event, '65', 640)" class="fn">newState</span><span class="pn">)</span>
                    <span onmouseout="hideTip(event, '57', 641)" onmouseover="showTip(event, '57', 641)" class="fn">events</span>
                <span class="pn">|</span> <span onmouseout="hideTip(event, '98', 642)" onmouseover="showTip(event, '98', 642)" class="uc">Error</span><span class="pn">(</span><span onmouseout="hideTip(event, '99', 643)" onmouseover="showTip(event, '99', 643)" class="fn">newVersion</span><span class="pn">,</span> <span onmouseout="hideTip(event, '100', 644)" onmouseover="showTip(event, '100', 644)" class="fn">newEvents</span><span class="pn">)</span> <span class="k">-&gt;</span>
                    <span class="c">// there was a concurrent write</span>
                    <span class="c">// catch-up missing events and retry</span>
                    <span class="k">let</span> <span onmouseout="hideTip(event, '65', 645)" onmouseover="showTip(event, '65', 645)" class="fn">newState</span> <span class="o">=</span> <span onmouseout="hideTip(event, '44', 646)" onmouseover="showTip(event, '44', 646)" class="m">List</span><span class="pn">.</span><span onmouseout="hideTip(event, '45', 647)" onmouseover="showTip(event, '45', 647)" class="id">fold</span> <span onmouseout="hideTip(event, '54', 648)" onmouseover="showTip(event, '54', 648)" class="fn">decider</span><span class="pn">.</span><span onmouseout="hideTip(event, '50', 649)" onmouseover="showTip(event, '50', 649)" class="id">evolve</span> <span onmouseout="hideTip(event, '61', 650)" onmouseover="showTip(event, '61', 650)" class="fn">state</span> <span onmouseout="hideTip(event, '100', 651)" onmouseover="showTip(event, '100', 651)" class="fn">newEvents</span>
                    <span onmouseout="hideTip(event, '104', 652)" onmouseover="showTip(event, '104', 652)" class="fn">handle</span> <span class="pn">(</span><span onmouseout="hideTip(event, '99', 653)" onmouseover="showTip(event, '99', 653)" class="fn">newVersion</span><span class="pn">,</span> <span onmouseout="hideTip(event, '65', 654)" onmouseover="showTip(event, '65', 654)" class="fn">newState</span><span class="pn">)</span>


            <span class="c">// load all past events to compute current state</span>
            <span class="c">// using snapshot if any</span>
            <span class="k">let</span> <span onmouseout="hideTip(event, '87', 655)" onmouseover="showTip(event, '87', 655)" class="fn">version</span><span class="pn">,</span> <span onmouseout="hideTip(event, '61', 656)" onmouseover="showTip(event, '61', 656)" class="fn">state</span> <span class="o">=</span> <span onmouseout="hideTip(event, '109', 657)" onmouseover="showTip(event, '109', 657)" class="fn">loadState</span> <span onmouseout="hideTip(event, '86', 658)" onmouseover="showTip(event, '86', 658)" class="fn">stream</span>
            <span onmouseout="hideTip(event, '104', 659)" onmouseover="showTip(event, '104', 659)" class="fn">handle</span> <span class="pn">(</span><span onmouseout="hideTip(event, '87', 660)" onmouseover="showTip(event, '87', 660)" class="fn">version</span><span class="pn">,</span> <span onmouseout="hideTip(event, '61', 661)" onmouseover="showTip(event, '61', 661)" class="fn">state</span><span class="pn">)</span>
</code></pre>
          <h2>
            <a name="Conclusion" class="anchor" href="#Conclusion"
              >Conclusion</a
            >
          </h2>
          <p>
            You may have noticed that all the infrastructure code we wrote to
            run the Decider is totally agnostic of the actual Domain Code. It
            could be running a simple game or a complex business system, it will
            still stay the same.
          </p>
          <p>
            The other interesting point is that decider can be run in many ways.
            Purely in memory, storing state in a database or an event store. No
            change on the domain code was required. This indicates a high level
            of independence on infrastructure.
          </p>
          <p>
            You can write the Domain code as Deciders, and choose afterward
            which kind of persistence you want to use, if any.
          </p>
          <p>
            The last interesting point, is that Deciders can be composed. But
            that's another story.
          </p>
          
        </div>
      </div>
    </div>
    
    

    <script type="module" src="/src/main.ts"></script>
  </body>
</html>
